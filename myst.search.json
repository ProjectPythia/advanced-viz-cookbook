{"version":"1","records":[{"hierarchy":{"lvl1":"Advanced Visualization Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook"},"content":"\n\n\n\n\n\n\nThis Project Pythia Cookbook covers advanced visualization techniques building upon and combining various Python packages.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":2},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Motivation"},"content":"The possibilities of data visualization in Python are almost endless. Already using matplotlib the workhorse behind many visualization packages, the user has a lot of customization options available to them. cartopy, metpy, seaborn, geocat-viz, and datashader are all also great packages that can offer unique additions to your Python visualization toolbox.\n\nThis cookbook will house various visualization workflow examples that use different visualization packages, highlight the differences in functionality between the packages, any noteable syntax distinctions, and demonstrate combining tools to achieve a specific outcome.","type":"content","url":"/#motivation","position":3},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":4},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Authors"},"content":"Julia Kent, \n\nAnissa Zacharias, \n\nOrhan Eroglu, \n\nPhilip Chmielowiec, \n\nJohn Clyne","type":"content","url":"/#authors","position":5},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":6},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":7},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":8},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Structure"},"content":"This cookbook is broken up into a few sections - a “Review of Visualization Foundations” intro that compares different visualization packages and plot elements, and then example workflows of advanced visualization applications that are further subdivided.","type":"content","url":"/#structure","position":9},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Review of Visualization Foundations","lvl2":"Structure"},"type":"lvl3","url":"/#review-of-visualization-foundations","position":10},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Review of Visualization Foundations","lvl2":"Structure"},"content":"Here we introduce the basics of geoscience visualization, the elements of a plot, different types of plots, and some unique considerations when dealing with model and measured data. We also share a comparison of different visualization packages available in the scientific Python ecosystem.","type":"content","url":"/#review-of-visualization-foundations","position":11},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Specialty Plots","lvl2":"Structure"},"type":"lvl3","url":"/#specialty-plots","position":12},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Specialty Plots","lvl2":"Structure"},"content":"There are some plot types that are unique to atmospheric science such as Taylor Diagrams and Skew-T plots. Here we use \n\nmetpy and \n\ngeocat-viz to demonstrate these specialty plots.\n\nWe also demonstrate the use of spaghetti plots for hurricane applications using packages such as \n\ncartopy and \n\ngeocat-viz.","type":"content","url":"/#specialty-plots","position":13},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Animation","lvl2":"Structure"},"type":"lvl3","url":"/#animation","position":14},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Animation","lvl2":"Structure"},"content":"Animated plots are great tools for science communication and outreach. We will demonstrate how to make your plots come to life. In this book, we use “animated plots” to refer to stable animations, such as the creation of GIFs or videos.","type":"content","url":"/#animation","position":15},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":16},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":17},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":18},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":19},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":20},{"hierarchy":{"lvl1":"Advanced Visualization Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your com\n\nClone the https://github.com/ProjectPythia/advanced-viz-cookbook repository: git clone https://github.com/ProjectPythia/advanced-viz-cookbook.git\n\nMove into the advanced-viz-cookbook directorycd advanced-viz-cookbook\n\nCreate and activate your \n\nConda environment from the environment.yml fileconda env create -f environment.yml\nconda activate advanced-viz-cookbook\n\nMove into the notebooks directory and start up Jupyterlabcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":21},{"hierarchy":{"lvl1":"Comparison of Visualization Packages"},"type":"lvl1","url":"/notebooks/comparison","position":0},{"hierarchy":{"lvl1":"Comparison of Visualization Packages"},"content":"","type":"content","url":"/notebooks/comparison","position":1},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/comparison#overview","position":2},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Overview"},"content":"There are nearly endless possibilities when it comes to data visualization in Python. Some of these choices can be overwhelming. This chapter aims to lay out and distinguish between different Python visualization libraries so that you are better equipped to make the right choice for your data visualization needs. This cookbook is not a comprehensive tutorial on these packages, but we can offer enough information and resources to help get you started.\n\nMatplotlib\n\nCartopy\n\nGeoCAT-viz\n\nMetPy\n\nVAPOR\n\nInfo\n\nThe plotting libraries mentioned here are either ones used extensively by the authors of this Cookbook OR ones that we get asked about a lot when giving data visualization tutorials. This does not cover every library that can be used for plotting in Python, but should cover the more popular packages you might come across.\n\nMissing a plotting library that you use and want others to know more about? Let us know by opening a \n\nGitHub Issue.\n\n","type":"content","url":"/notebooks/comparison#overview","position":3},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/comparison#prerequisites","position":4},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nCartopy\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/comparison#prerequisites","position":5},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Matplotlib"},"type":"lvl2","url":"/notebooks/comparison#matplotlib","position":6},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Matplotlib"},"content":"\n\nMatplotlib is the workhorse of the Python visualization landscape. It is a comprehensive plotting library that has the capacity to make static, animated, or interactive visualizations. It is hard to imagine plotting in Python without first getting comfortable with Matplotlib. Be sure to check out the \n\nMatplotlib documentation as well as the \n\nPythia foundations chapter on Matplotlib for guidance.\n\nMatplotlib’s syntax should feel familiar to anyone who has plotted data in Matlab.\n\nHere is a \n\nsimple plotting example from Matplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nplt.show()\n\n","type":"content","url":"/notebooks/comparison#matplotlib","position":7},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Cartopy"},"type":"lvl2","url":"/notebooks/comparison#cartopy","position":8},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Cartopy"},"content":"\n\nCartopy is a Python package for plotting data on the globe. It is the go-to package for plotting maps, dealing with different projections, and adding surface features to your plot. Cartopy is buit on top of \n\nPROJ, NumPy, \n\nShapely, and Matplotlib. To learn more about what Cartopy can do, check out the \n\nCartopy documentation and the \n\nPythia Foundations Cartopy Chapter.\n\nYou may have heard about \n\nBasemap, another geoscience plotting library, which was deprecated in favor of Cartopy.\n\nHere is a \n\nsimple plotting example from Cartopy:\n\nimport cartopy.crs as ccrs\n\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n\nplt.show()\n\n","type":"content","url":"/notebooks/comparison#cartopy","position":9},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"GeoCAT-Viz"},"type":"lvl2","url":"/notebooks/comparison#geocat-viz","position":10},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"GeoCAT-Viz"},"content":"\n\nThe GeoCAT team at the NSF National Center for Atmospheric Research (NSF NCAR) aims to help scientists transitioning from \n\nNCL to Python. Out of this team come three different visualization aids: the \n\nGeoCAT-examples visualization gallery which contains tons of different plotting examples that you can use as a starting place for your figures, \n\nGeoCAT-applications which is designed to be a quick reference guide demonstrating capabilities within the scientific Python ecosystem, and the \n\nGeoCAT-viz package (documentation) which contains many convenience functions that formerly existed in NCL and/or for making Python plots look publication-ready.\n\nHere is a simple example of a GeoCAT-viz convenience function:\n\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geocat.datafiles as gdf\nimport geocat.viz as gv\n\n# Open a netCDF data file using xarray default engine and load the data into xarrays\nds = xr.open_dataset(gdf.get(\"netcdf_files/mxclim.nc\"))\nU = ds.U[0, :, :]\n\n# Generate figure (set its size (width, height) in inches) and axes\nplt.figure(figsize=(6, 6))\nax = plt.axes()\n\n# Set y-axis to have log-scale\nplt.yscale('log')\n\n# Specify which contours should be drawn\nlevels = np.linspace(-55, 55, 23)\n\n# Plot contour lines\nlines = U.plot.contour(ax=ax,\n                       levels=levels,\n                       colors='black',\n                       linewidths=0.5,\n                       linestyles='solid',\n                       add_labels=False)\n\n# Invert y-axis\nax.invert_yaxis()\n\n# Create second y-axis to show geo-potential height.\naxRHS = gv.add_height_from_pressure_axis(ax, heights=[4, 8])\n\nplt.show();\n\n","type":"content","url":"/notebooks/comparison#geocat-viz","position":11},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"MetPy"},"type":"lvl2","url":"/notebooks/comparison#metpy","position":12},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"MetPy"},"content":"\n\nMetPy is a collection of tools for data I/O, analysis, and visualization with weather data. MetPy offers some useful functionality for unique plots such as Skew-T diagrams, as well as declaritive plotting functionality. Check out the \n\nMetPy documentation.\n\nHere is a simple Skew-T plot from their \n\nGetting Started documentation:\n\nimport metpy.calc as mpcalc\nfrom metpy.plots import SkewT\nfrom metpy.units import units\n\nfig = plt.figure(figsize=(9, 9))\nskew = SkewT(fig)\n\n# Create arrays of pressure, temperature, dewpoint, and wind components\np = [902, 897, 893, 889, 883, 874, 866, 857, 849, 841, 833, 824, 812, 796, 776, 751,\n     727, 704, 680, 656, 629, 597, 565, 533, 501, 468, 435, 401, 366, 331, 295, 258,\n     220, 182, 144, 106] * units.hPa\nt = [-3, -3.7, -4.1, -4.5, -5.1, -5.8, -6.5, -7.2, -7.9, -8.6, -8.9, -7.6, -6, -5.1,\n     -5.2, -5.6, -5.4, -4.9, -5.2, -6.3, -8.4, -11.5, -14.9, -18.4, -21.9, -25.4,\n     -28, -32, -37, -43, -49, -54, -56, -57, -58, -60] * units.degC\ntd = [-22, -22.1, -22.2, -22.3, -22.4, -22.5, -22.6, -22.7, -22.8, -22.9, -22.4,\n      -21.6, -21.6, -21.9, -23.6, -27.1, -31, -38, -44, -46, -43, -37, -34, -36,\n      -42, -46, -49, -48, -47, -49, -55, -63, -72, -88, -93, -92] * units.degC\n\n# Calculate parcel profile\nprof = mpcalc.parcel_profile(p, t[0], td[0]).to('degC')\nu = np.linspace(-10, 10, len(p)) * units.knots\nv = np.linspace(-20, 20, len(p)) * units.knots\n\nskew.plot(p, t, 'r')\nskew.plot(p, td, 'g')\nskew.plot(p, prof, 'k')  # Plot parcel profile\nskew.plot_barbs(p[::5], u[::5], v[::5])\n\nskew.ax.set_xlim(-50, 15)\nskew.ax.set_ylim(1000, 100)\n\n# Add the relevant special lines\nskew.plot_dry_adiabats()\nskew.plot_moist_adiabats()\nskew.plot_mixing_lines()\n\nplt.show();\n\n","type":"content","url":"/notebooks/comparison#metpy","position":13},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"VAPOR"},"type":"lvl2","url":"/notebooks/comparison#vapor","position":14},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"VAPOR"},"content":"\n\nVAPOR stands for the Visualization and Analysis Platform for Ocean, Atmosphere, and Solar Researchers and is another project from NCAR. VAPOR provides an interactive 3D visualization environment.  Traditionally users interacted through a graphical user interface (GUI), but it now has a Python API as well. Learn more at the \n\nVAPOR documentation. Note that VAPOR requires a GPU-enabled environment to run.\n\nInfo\n\nFor more VAPOR content, be sure to check out the \n\nVAPOR Pythia Cookbook.\n\nInteractive visualization libraries such as Plotly, Seaborn, Bokeh, and hvPlot will be explored in a separate interactive plotting cookbook.\n\n","type":"content","url":"/notebooks/comparison#vapor","position":15},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/comparison#summary","position":16},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Summary"},"content":"Each Python plotting library offers a slightly different niche in the data visualization world. Some are better for creating publication figures (matplotlib, cartopy, metpy, geocat-viz, uxarray) while others offer interactive functionality that is great for websites, demonstrations, and other forms of engagement (holoviews, seaborn, plotly, bokeh, and vapor). Hopefully the mini examples on this page allow you to play around and see which user interfaces you like best for your visualization needs.","type":"content","url":"/notebooks/comparison#summary","position":17},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/comparison#whats-next","position":18},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next up let’s discuss elements of \n\ngood data visualization.\n\n","type":"content","url":"/notebooks/comparison#whats-next","position":19},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/comparison#resources-and-references","position":20},{"hierarchy":{"lvl1":"Comparison of Visualization Packages","lvl2":"Resources and references"},"content":"Matplotlib documentation\n\nCartopy documentation\n\nGeoCAT-examples visualization gallery\n\nGeoCAT-viz documentation\n\nMetPy documentation\n\nVAPOR documentation\n\nPlotly Python documentation\n\nSeaborn documentation\n\nBokeh documentation\n\nUXarray documentation\n\nhvPlot documentation\n\nHoloviews documentation\n\nDatashader documentation","type":"content","url":"/notebooks/comparison#resources-and-references","position":21},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?"},"type":"lvl1","url":"/notebooks/good-viz","position":0},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?"},"content":"","type":"content","url":"/notebooks/good-viz","position":1},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/good-viz#overview","position":2},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Overview"},"content":"What makes a good visualization? We want graphics to be eye catching and informative. In this chapter we’ll discuss different aspects that can affect the quality of your figures and specific considerations relevant to the geosciences.\n\nThe Importance of Data Visualization\n\nPublication Ready Figures\n\nThe Problem with Rainbow Colormaps\n\nMisleading Visualizations\n\n","type":"content","url":"/notebooks/good-viz#overview","position":3},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/good-viz#prerequisites","position":4},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nCartopy\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geocat.viz as gv\n\n","type":"content","url":"/notebooks/good-viz#prerequisites","position":5},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"The Importance of Data Visualization"},"type":"lvl2","url":"/notebooks/good-viz#the-importance-of-data-visualization","position":6},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"The Importance of Data Visualization"},"content":"It is important to use pictures to show data because we can visually detect patterns that could be lost in statistical analysis. All scientific disciplines use data visualizations to communicate concepts.\n\nHere we have a figure from \n\nAutodesk that shows a “Datasaurus” and 12 other datasets that share the same statistical information (mean, standard deviation, etc). We can see immediately that visually are telling very different stories: be it a dinosaur, a star, an oval, concentric ovals, or a series of lines (perhaps weather fronts).\n\n","type":"content","url":"/notebooks/good-viz#the-importance-of-data-visualization","position":7},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Publication Ready Figures"},"type":"lvl2","url":"/notebooks/good-viz#publication-ready-figures","position":8},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Publication Ready Figures"},"content":"For your figure to be publication ready, you probably want to change some of Matplotlib’s default plotting settings: selecting font sizes for your titles and labels, changing figure sizes, or subplot/colormap layout.\n\nTo demonstrate this, let’s look at an example:\n\n# fake data\nx = [0, 1, 2, 3, 4, 5]\ny = [0, 3, 6, 9, 12, 15]\n \n# plot\nplt.plot(x, y)\n\n# annotate\nplt.title('Title')\nplt.xlabel('X Label')\nplt.ylabel('Y Label')\n\nplt.show();\n\nNow let’s show some customization options:\n\n# fake data\nx = [0, 1, 2, 3, 4, 5]\ny = [0, 3, 6, 9, 12, 15]\n \n# plot\nplt.plot(x, y, '--', color='red')\n\n# annotate\nplt.title('Title', fontsize=20)\nplt.xlabel('X Label', fontsize=16)\nplt.ylabel('Y Label', fontsize=16)\n\nplt.show();\n\n","type":"content","url":"/notebooks/good-viz#publication-ready-figures","position":9},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"Matplotlib Global Parameters","lvl2":"Publication Ready Figures"},"type":"lvl3","url":"/notebooks/good-viz#matplotlib-global-parameters","position":10},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"Matplotlib Global Parameters","lvl2":"Publication Ready Figures"},"content":"Matplotlib has defaults for font sizes and all sorts of attributes of a plot. Instead of setting your fontsize in every script, it is possible to set global parameters to change the default values of these attributes.\n\nYou can veiw the globoal parameters options and their current settings with:\n\nmpl.rcParams.keys\n\nTo change any given parameter you would use the following command (replacing your parameter and value, of course):\n\nmpl.rcParams['font.family'] = 'Arial'\n\n","type":"content","url":"/notebooks/good-viz#matplotlib-global-parameters","position":11},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"Using GeoCAT-viz","lvl2":"Publication Ready Figures"},"type":"lvl3","url":"/notebooks/good-viz#using-geocat-viz","position":12},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"Using GeoCAT-viz","lvl2":"Publication Ready Figures"},"content":"The GeoCAT-viz package also has many utility functions for making your plots looks publication ready in fewer lines of code. The defaults of GeoCAT-viz keyword-arguments are set to resemble the style of NCL.\n\n# fake data\nx = [0, 1, 2, 3, 4, 5]\ny = [0, 3, 6, 9, 12, 15]\n \n# plot\nplt.plot(x, y)\n\n# annotate\nplt.title('Title')\nplt.xlabel('X Label')\nplt.ylabel('Y Label')\n\ngv.set_titles_and_labels(plt.gca())\n\nplt.show();\n\n","type":"content","url":"/notebooks/good-viz#using-geocat-viz","position":13},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"The Problem with Rainbow Colormaps"},"type":"lvl2","url":"/notebooks/good-viz#the-problem-with-rainbow-colormaps","position":14},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"The Problem with Rainbow Colormaps"},"content":"Rainbow colormaps are visually beautiful, but are falling out of favor because\n\nThey are not colorblind friendly and\n\nThey do not print out in grayscale in a meaningful way.\n\nBoth of these issues can be addressed by being careful about your colormaps lightness-values.\n\nSome colormaps options are perceptually uniform (the same lightness value), sequentially ordered (goes from lighter to darker), or diverging (lightest or darkest at a set point and uniformly changes lightness going out). A rainbow colormap however is lighter or darker in arbitrary places and it affects how we interpret data (especially if it was printed out in grayscale).\n\nFor example, from \n\nMatplotlib’s Choosing a Colormap documentation here are some “good” colormaps:\n\n\n\nAnd here are miscellaneous colormaps:\n\n\n\nLooking at the colors in grayscale helps to understand why we might prefer a sequentially ordered colormap. Some grayscale values are duplicated and the reader will not know if it is a high or low value.\n\nAnother consideration that can help those who are visually impaired is to make sure your figure captions are descriptive. Use words to paint a picture of what is displayed, not just the conclusions you want the reader to reach.\n\n","type":"content","url":"/notebooks/good-viz#the-problem-with-rainbow-colormaps","position":15},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Misleading Visualizations"},"type":"lvl2","url":"/notebooks/good-viz#misleading-visualizations","position":16},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Misleading Visualizations"},"content":"The scales or colors we choose to use for data visualization affect how people interpret figures. You should strive to make your visualizations as accurate and as informative as possible. Here are some examples that demonstrate just how different a figure can look based on these choices you make. Do not intentionally mislead your audience!\n\nPerhaps the most common data visualization manipulation is to change the Y-scale. If a plot does not begin at 0, small changes in magnitude can be exaggerated. Similarly a logarithmic scale will amplify changes. This is not always disingenuous, sometimes these changes are what you want to highlight, the pattern you want to draw attention to. Just make sure it is appropriate for your use case and documented. Alternatively, extending the Y-axis too large has the opposite affect and smooths out the differences in data.\n\nx = [1, 2, 3, 4, 5]\ny = [1101, 1011, 1111, 1070, 1050]\n\n\nfig, (ax1, ax2, ax3, ax4) = plt.subplots(4)\nfig.tight_layout()\n\nax1.bar(x,y)\nax1.set_title(\"Default Y-Scale Starts at 0\")\n\nax2.bar(x,y)\nax2.set_ylim(1000)\nax2.set_title(\"Y-Scale Starts at 1000\")\n\nax3.bar(x,y)\nax3.set_yscale(\"log\")\nax3.set_title(\"Y-Scale is Logarithmic\");\n\nax4.bar(x,y)\nax4.set_ylim(0, 2000)\nax4.set_title(\"Y-Scale is Extended\");\n\nOther examples of data visualization manipulation include improper scaling, cherry picking a small non-representative subset of the data to display, displaying pie charts at a slant (pie charts are hard to interpet as is), and using unexpected colormaps.\n\n\n\n","type":"content","url":"/notebooks/good-viz#misleading-visualizations","position":17},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/good-viz#summary","position":18},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Summary"},"content":"It is important to have accurate, engaging, and representative data visualization to accumpany your research, both for data exploration as part of the scientific process, for communication of results, and education/outreach efforts. Visually we pick up on patterns that statistics alone may not convey. However, an over reliance on data visualization can make science less accessible to those with vision disabilities. It is important to be cognizant of the patterns our minds pick up, be it based on color or y-axis scaling, so that we can avoid misleading our audience and more accurately convey the narrative inherent to the data.","type":"content","url":"/notebooks/good-viz#summary","position":19},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/good-viz#whats-next","position":20},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl3":"What’s next?","lvl2":"Summary"},"content":"Let’s break down the different components of data visualization in \n\nPlot Elements.\n\n","type":"content","url":"/notebooks/good-viz#whats-next","position":21},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/good-viz#resources-and-references","position":22},{"hierarchy":{"lvl1":"What Makes for Good Data Visualization?","lvl2":"Resources and references"},"content":"Autodesk\n\nMatplotlib’s Choosing a Colormap documentation\n\nGeoCAT-examples Gallery\n\nNWSC script\n\nBeyond Visuals: Examining the Experiences of Geoscience\nProfessionals With Vision Disabilities in Accessing Data Visualizations\n\nSame Stats Different Graphs: Generating Datasets with Varied Appearance and\nIdentical Statistics through Simulated Annealing\n\nAlberto Cairo’s How Charts Lie: Getting Smarter about Visual Information\n\nMisleading Data Visualization – What to Avoid","type":"content","url":"/notebooks/good-viz#resources-and-references","position":23},{"hierarchy":{"lvl1":"Plot Elements"},"type":"lvl1","url":"/notebooks/plot-elements","position":0},{"hierarchy":{"lvl1":"Plot Elements"},"content":"","type":"content","url":"/notebooks/plot-elements","position":1},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/plot-elements#prerequisites","position":2},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nCartopy\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\nimport xarray as xr\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport geocat.viz as gv\n\n","type":"content","url":"/notebooks/plot-elements#prerequisites","position":3},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Data"},"type":"lvl2","url":"/notebooks/plot-elements#data","position":4},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Data"},"content":"The first piece of data visualization is the data!\n\nLet’s generate some dummy data to work with:\n\nx = np.linspace(0, 20, 1000)\ny1 = np.sin(x)\ny2 = np.cos(x)\n\n","type":"content","url":"/notebooks/plot-elements#data","position":5},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Figure"},"type":"lvl2","url":"/notebooks/plot-elements#figure","position":6},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Figure"},"content":"The figure is the object that contains your entire visualization. Creating a figure tends to be the first step in plotting, even if it doesn’t currently show anything:\n\nfig = plt.figure(figsize=(9.5, 8))\n\n","type":"content","url":"/notebooks/plot-elements#figure","position":7},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Axis"},"type":"lvl2","url":"/notebooks/plot-elements#axis","position":8},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Axis"},"content":"We then add axes to our plot. You can add multiple axes to one plot in order to produce subplots, or just one. Axes will automatically inherit their limits from the data plotted, or can be manually set.\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\n","type":"content","url":"/notebooks/plot-elements#axis","position":9},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Plot"},"type":"lvl2","url":"/notebooks/plot-elements#plot","position":10},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Plot"},"content":"Adding the data to the figure can be done through several different plot types: line, contour, bar, histogram. Here we use two line plots:\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\nax.plot(x,y1)\nax.plot(x,y2);\n\n","type":"content","url":"/notebooks/plot-elements#plot","position":11},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Titles and Labels"},"type":"lvl2","url":"/notebooks/plot-elements#titles-and-labels","position":12},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Titles and Labels"},"content":"Titles and labels are important for indicating what the figure is plotting. It is a good idea to include relevant units in your axis labels.\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\nax.plot(x,y1)\nax.plot(x,y2)\n\nax.set_title(\"Dummy Data\")\nax.set_xlabel(\"X (radians)\");\n\n","type":"content","url":"/notebooks/plot-elements#titles-and-labels","position":13},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Legends"},"type":"lvl2","url":"/notebooks/plot-elements#legends","position":14},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Legends"},"content":"If you’re plotting multiple lines of data, it’s a good idea to include a legend. Here is how you call or point to the legend:\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\nax.plot(x,y1,label='sine')\nax.plot(x,y2,label='cosine')\n\nax.set_title(\"Dummy Data\")\nax.set_xlabel(\"X (radians)\")\n\nplt.legend(loc=\"upper left\");\n\n","type":"content","url":"/notebooks/plot-elements#legends","position":15},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Colorbars"},"type":"lvl2","url":"/notebooks/plot-elements#colorbars","position":16},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Colorbars"},"content":"While legends are more appropriate for line or bar plots, colorbars are most commonly used for contour plots and sometimes to apply a third level of dimension to a scatter plot.\n\nLet’s shift our example to better demonstrate a colorbar by workign with a filled contour plot:\n\n# Generate dummy data\ndata = [[1, 4, 5, 6, 8.2],\n        [9, 8.4, 10, 10.6, 9.7],\n        [4.4, 5, 0, 6.6, 1.4],\n        [4.6, 5.2, 1.5, 7.6, 2.4]]\n\n# Convert data into type xarray.DataArray\ndata = xr.DataArray(data,\n                    dims=[\"lat\", \"lon\"],\n                    coords=dict(lat=np.arange(4), lon=np.arange(5)))\n\ndata\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\npcm = ax.contourf(data,cmap='viridis')\n\nax.set_title(\"Dummy Data\")\nax.set_xlabel(\"Longitude (\\N{DEGREE SIGN})\")\nax.set_ylabel(\"Latitude (\\N{DEGREE SIGN})\")\n\nfig.colorbar(pcm,ax=ax);\n\n","type":"content","url":"/notebooks/plot-elements#colorbars","position":17},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Annotations"},"type":"lvl2","url":"/notebooks/plot-elements#annotations","position":18},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Annotations"},"content":"Additional annotations allow you to specify some text and a location to indicate almost anything.\n\nHere we use GeoCAT-viz to add annotations to the maxima in a contour plot:\n\nfig = plt.figure(figsize=(9.5, 8))\nax = plt.axes()\n\npcm = ax.contourf(data,cmap='viridis')\n\nax.set_title(\"Dummy Data\")\nax.set_xlabel(\"Longitude (\\N{DEGREE SIGN})\")\nax.set_ylabel(\"Latitude (\\N{DEGREE SIGN})\")\n\nfig.colorbar(pcm,ax=ax)\n\n# Find local maximum with GeoCAT-Viz find_local_extrema\nlmax = gv.find_local_extrema(data, eType='High')[0]\n\n# Plot labels for local mins\nmax_value = data.data[lmax[1]][lmax[0]]\nax.text(lmax[0], lmax[1],'Maxima = '+str(max_value))\n\n# Show plot\nplt.show();\n\n\n\n","type":"content","url":"/notebooks/plot-elements#annotations","position":19},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/plot-elements#summary","position":20},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Summary"},"content":"There are several key elements to a Python plot and knowing what they are called is instrumental to begin your journey for further customization.","type":"content","url":"/notebooks/plot-elements#summary","position":21},{"hierarchy":{"lvl1":"Plot Elements","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/plot-elements#whats-next","position":22},{"hierarchy":{"lvl1":"Plot Elements","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next up, the specialty plots called \n\nTaylor Diagrams.\n\n","type":"content","url":"/notebooks/plot-elements#whats-next","position":23},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/plot-elements#resources-and-references","position":24},{"hierarchy":{"lvl1":"Plot Elements","lvl2":"Resources and references"},"content":"","type":"content","url":"/notebooks/plot-elements#resources-and-references","position":25},{"hierarchy":{"lvl1":"Taylor Diagrams"},"type":"lvl1","url":"/notebooks/taylor-diagrams","position":0},{"hierarchy":{"lvl1":"Taylor Diagrams"},"content":"","type":"content","url":"/notebooks/taylor-diagrams","position":1},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/taylor-diagrams#overview","position":2},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Overview"},"content":"Taylor diagrams are a visual way of representing a statistical summary of how at least two datasets compare, where all plotted datasets are statistically compared to the same reference dataset (typically climate observations). Taylor diagrams are radial plots, with distance from the origin determined by a normalized standard deviation of your dataset (normalized by dividing it by the standard deviation of the reference or observational dataset) and the angle determined by the correlation coefficient between your dataset and the reference.\n\nTaylor diagrams are popular for displaying climatological data because the normalization of variances helps account for the widely varying numerical values of geoscientific variables such as temperature or precipitation.\n\nThis notebook explores how to create and customize Taylor diagrams using geocat-viz. See the more information on \n\ngeocat-viz.TaylorDiagram.\n\nCreating a Simple Taylor Diagram\n\nNecessary Statistical Analysis\n\nPlotting Different Ensemble Members\n\nPlotting Multiple Models\n\nPlotting Multiple Variables\n\nPlotting Bias\n\nVariants\n\n","type":"content","url":"/notebooks/taylor-diagrams#overview","position":3},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/taylor-diagrams#prerequisites","position":4},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\n\nimport cftime\n\nimport geocat.viz as gv\nimport geocat.datafiles as gdf\n\n","type":"content","url":"/notebooks/taylor-diagrams#prerequisites","position":5},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Creating a Simple Taylor Diagram"},"type":"lvl2","url":"/notebooks/taylor-diagrams#creating-a-simple-taylor-diagram","position":6},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Creating a Simple Taylor Diagram"},"content":"Before getting into the data computation necessary to create a Taylor diagram, let’s demonstrate how to make the simplest Taylor diagram plot. Here we are using sample data with a normalized standard deviation of 0.6 and a correlation coefficient of 0.24.\n\n# Create figure and Taylor Diagram instance\nfig = plt.figure(figsize=(12, 12))\ntaylor = gv.TaylorDiagram(fig=fig, label='REF')\n\n# Draw diagonal dashed lines from origin to correlation values\n# Also enforces proper X-Y ratio\ntaylor.add_xgrid(np.array([0.6, 0.9]))\n\n# Add a model dataset of one point\ntaylor.add_model_set(stddev=[.6], corrcoef=[.24]);\n\nplt.title(\"Simple Taylor Diagram\", size=26, pad=45); # Need to move title up\n\n","type":"content","url":"/notebooks/taylor-diagrams#creating-a-simple-taylor-diagram","position":7},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Necessary Statistical Analysis"},"type":"lvl2","url":"/notebooks/taylor-diagrams#necessary-statistical-analysis","position":8},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Necessary Statistical Analysis"},"content":"To make understanding a Taylor Diagram more meaningful or intuitive, let’s use some real data. Here we are going to use ERA5 reanalysis data as our observational dataset. CMIP5 temperature data from various representative concentration pathways (RCPs) and ensemble members as our model data.\n\nBecause these dataset can be so large, some data pre-processing has been done already to the datasets used in this example.\n\nERA5 and CMIP5 data have been spatially averaged (removing latitudinal and longitudinal dimensions)\n\nERA5 and CMIP5 data have been indexed to only include the year 2022\n\nAll ensembles from a given CMIP5 RCP model have been combined into one dataset.\n\nTemperature and pressure variables from ERA5 have been combined into one dataset.\n\n","type":"content","url":"/notebooks/taylor-diagrams#necessary-statistical-analysis","position":9},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Preparing the Reference (Observed) Dataset","lvl2":"Necessary Statistical Analysis"},"type":"lvl3","url":"/notebooks/taylor-diagrams#preparing-the-reference-observed-dataset","position":10},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Preparing the Reference (Observed) Dataset","lvl2":"Necessary Statistical Analysis"},"content":"Let’s use geocat.datafiles to open up our ERA5 reanalysis data.\n\nThis dataset has two variables:\n\n2T_GDSO_SFC which refers to the air temperature 2 meters above the surface, and\n\nSP_GDSO_SFC which is surface pressure.\n\nFor this dataset, we still need to resample our data to monthly to match the monthly CMIP5 data.\n\nNotice that our time coordinate is in datetime64, we will have to manipulate either ERA5 or CMIP5 data to use the same time formatting system.\n\nera5 = xr.open_dataset(gdf.get('netcdf_files/era5_2022_2mtemp_spres_xyav.nc'))\nera5\n\n# Change hourly data to monthly\nera5 = era5.rename({'initial_time0_hours': 'time'}) # Changing dimension name for convenience\nera5_resampled = era5.resample(time='MS').mean()\noffset = pd.tseries.frequencies.to_offset('15D') # use offsest to adjust to the center of each month as in CMIP5 data\nera5_resampled['time'] = era5_resampled.get_index('time') + offset\n\nera5_resampled\n\nera5_temp = era5_resampled['2T_GDS0_SFC'] # Because this variable name starts with a number `era5_resampled.2T_GDS0_SFC` would give an error s\n\n# Take a look at our final temperature data\nera5_temp\n\n","type":"content","url":"/notebooks/taylor-diagrams#preparing-the-reference-observed-dataset","position":11},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Preparing the model datasets","lvl2":"Necessary Statistical Analysis"},"type":"lvl3","url":"/notebooks/taylor-diagrams#preparing-the-model-datasets","position":12},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Preparing the model datasets","lvl2":"Necessary Statistical Analysis"},"content":"Here our CMIP5 data is originally sourced from the \n\nEarth System Grid Federation. Let’s first look at our RCP8.5 model, typically referred to as “business as usual” because it is expected to be the mostly likely outcome without improving greenhouse gas mitigation efforts.\n\nTo compare this data with the ERA5 data we need to convert our data to datetime64.\n\ntas_rcp85 = xr.open_dataset(gdf.get('netcdf_files/tas_Amon_CanESM2_rcp85_2022_xyav.nc'))\n\ntas_rcp85\n\ntas_rcp85['time'] = tas_rcp85.indexes['time'].to_datetimeindex()\ntas_rcp85\n\n","type":"content","url":"/notebooks/taylor-diagrams#preparing-the-model-datasets","position":13},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Perform the statistical calculations","lvl2":"Necessary Statistical Analysis"},"type":"lvl3","url":"/notebooks/taylor-diagrams#perform-the-statistical-calculations","position":14},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"Perform the statistical calculations","lvl2":"Necessary Statistical Analysis"},"content":"We need to compute the standard deviation for both our ERA5 observed temperature data and our CMIP5 RCP8.5 modeled temperature.\n\nFind the correlation coefficient between them.\n\nThen, divide the model standard deviation by the observed standard deviation to normalize it around the value 1.\n\nIn the next cell we will perform this calculation for all ensemble members.\n\ntemp_rcp85_std = []\ntemp_rcp85_corr = []\n\nstd_temp_obsv = float(era5_temp.std().values)\n\nfor em in list(tas_rcp85.data_vars): # for each ensemble member\n    std = float(tas_rcp85[em].std().values)\n    std_norm = std / std_temp_obsv\n\n    corr= float(xr.corr(era5_temp, tas_rcp85[em]).values)\n\n    temp_rcp85_std.append(std_norm)\n    temp_rcp85_corr.append(corr)\n\n","type":"content","url":"/notebooks/taylor-diagrams#perform-the-statistical-calculations","position":15},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Different Ensemble Members"},"type":"lvl2","url":"/notebooks/taylor-diagrams#plotting-different-ensemble-members","position":16},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Different Ensemble Members"},"content":"One application of a Taylor Diagram application is to plot the same variable from different ensembles of the same climate model.\n\nThis Taylor diagram differs from our simple example in that we’ve specified more keyword arguments in our taylor.add_model_set() call, specifying how we want our dots to be drawn. We’ve also added a legend of ensemble members with taylor.add_model_name().\n\n# Create figure and Taylor Diagram instance\nfig = plt.figure(figsize=(12, 12))\ntaylor = gv.TaylorDiagram(fig=fig, label='REF')\nax = plt.gca()\n\n# Draw diagonal dashed lines from origin to correlation values\n# Also enforces proper X-Y ratio\ntaylor.add_xgrid(np.array([0.6, 0.9]))\n\n# Add model sets for p and t datasets\ntaylor.add_model_set(\n    temp_rcp85_std,\n    temp_rcp85_corr,\n    fontsize=20,  # specify font size\n    xytext=(-5, 10),  # marker label location, in pixels\n    color='red', # specify marker color\n    marker='o', # specify marker shape\n    facecolors='none', # specify marker fill\n    s=100)  # marker size\n\n# Add legend of ensemble names\nnamearr = list(tas_rcp85.data_vars)\ntaylor.add_model_name(namearr, fontsize=16)\n\n# Add figure title\nplt.title(\"RCP85 Temperature\", size=26, pad=45);\n\n","type":"content","url":"/notebooks/taylor-diagrams#plotting-different-ensemble-members","position":17},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Multiple Models"},"type":"lvl2","url":"/notebooks/taylor-diagrams#plotting-multiple-models","position":18},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Multiple Models"},"content":"Another potential use case for a Taylor diagram is to plot multiple models. Here we compare RCP2.6, RCP4.5, and RCP8.5 together.\n\nBecause it isn’t meaningful to compare ensemble members across model runs (the nature of the perturbations isn’t reliably similar across RCPs or labs), we will look at the first ensemble r1i1p1 for all models. For your analysis, you might find it more meaningful to average across ensemble members, but we’ll keep it simple for this plotting example.\n\nOf course, you could still chose to display more information on one graph, but there is no real conection between the first ensemble of one model versus another.\n\nIn this final example, we’ll add another layer of complexity to our Taylor Diagram plot with contour lines of constant root mean squared error (RMSE).\n\n# Open RCP26 and RCP45 files\ntas_rcp26 = xr.open_dataset(gdf.get('netcdf_files/tas_Amon_CanESM2_rcp26_2022_xyav.nc'))\ntas_rcp26['time'] = tas_rcp26.indexes['time'].to_datetimeindex()\n\ntas_rcp45 = xr.open_dataset(gdf.get('netcdf_files/tas_Amon_CanESM2_rcp45_2022_xyav.nc'))\ntas_rcp45['time'] = tas_rcp45.indexes['time'].to_datetimeindex()\n\n# Perform statistical analysis to create our standard deviation and correlation coefficient lists\ntemp_rcp26_std = float(tas_rcp26['r1i1p1'].std().values) \ntemp_rcp26_std_norm = temp_rcp26_std / std_temp_obsv\ntemp_rcp26_corr = float(xr.corr(era5_temp, tas_rcp26['r1i1p1']).values)\n\ntemp_rcp45_std = float(tas_rcp45['r1i1p1'].std().values)\ntemp_rcp45_std_norm = temp_rcp45_std / std_temp_obsv\ntemp_rcp45_corr = float(xr.corr(era5_temp, tas_rcp45['r1i1p1']).values)\n\ntemp_std = [temp_rcp26_std_norm, temp_rcp45_std_norm, temp_rcp85_std[0]]\ntemp_corr = [temp_rcp26_corr, temp_rcp45_corr, temp_rcp85_corr[0]]\n\n# Create figure and Taylor Diagram instance\nfig = plt.figure(figsize=(12, 12))\ntaylor = gv.TaylorDiagram(fig=fig, label='REF')\nax = plt.gca()\n\n# Draw diagonal dashed lines from origin to correlation values\n# Also enforces proper X-Y ratio\ntaylor.add_xgrid(np.array([0.6, 0.9]))\n\n# Add model set for temp dataset\ntaylor.add_model_set(\n    temp_std,\n    temp_corr,\n    fontsize=20,\n    xytext=(-5, 10),  # marker label location, in pixels\n    color='red',\n    marker='o',\n    facecolors='none',\n    s=100)  # marker size\n\n#gv.util.set_axes_limits_and_ticks(ax, xlim=[0,2])\n\nnamearr = ['rcp26', 'rcp45', 'rcp85']\ntaylor.add_model_name(namearr, fontsize=16)\n\n# Add figure title\nplt.title(\"CMIP5 Temperature - First Ensemble Member\", size=26, pad=45)\n\n# Add constant centered RMS difference contours.\ntaylor.add_contours(levels=np.arange(0, 1.1, 0.25),\n                 colors='lightgrey',\n                 linewidths=0.5);\n\nBased on these three RCPs it looks like RCP8.5 has the closest correlation to our observed climate behavior, but RCP2.6 has a closer standard deviation to what we experience. Based on your selected data, scientific interpretations may vary.\n\n","type":"content","url":"/notebooks/taylor-diagrams#plotting-multiple-models","position":19},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Multiple Variables"},"type":"lvl2","url":"/notebooks/taylor-diagrams#plotting-multiple-variables","position":20},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Multiple Variables"},"content":"A Taylor Diagram can support multiple model sets, you simply need to call taylor.add_model_set() multiple times. By adding the label kwarg and calling taylor.add_legend() you can add a label distinguishing between the two sets.\n\nSince we’ve already demonstrated the statistical analysis necessary to perform Taylor Diagrams, the following example will be using sample data.\n\nHere we make sample data for 7 common climate model variables, for two different models.\n\n# Create sample data\n\n# Model A\na_sdev = [1.230, 0.988, 1.092, 1.172, 1.064, 0.966, 1.079]  # normalized standard deviation\na_ccorr = [0.958, 0.973, 0.740, 0.743, 0.922, 0.982, 0.952]  # correlation coefficient\n\n# Model B\nb_sdev = [1.129, 0.996, 1.016, 1.134, 1.023, 0.962, 1.048]  # normalized standard deviation\nb_ccorr = [0.963, 0.975, 0.801, 0.814, 0.946, 0.984, 0.968]  # correlation coefficient\n\n# Sample Variable List\nvar_list = ['Surface Pressure', '2m Temp', 'Dew Point Temp', 'U Wind', 'V Wind', 'Precip', 'Cloud Cov']\n\n# Create figure and TaylorDiagram instance\nfig = plt.figure(figsize=(10, 10))\ntaylor = gv.TaylorDiagram(fig=fig, label='REF')\n\n# Draw diagonal dashed lines from origin to correlation values\n# Also enforces proper X-Y ratio\ntaylor.add_xgrid(np.array([0.6, 0.9]))\n\n# Add models to Taylor diagram\ntaylor.add_model_set(a_sdev,\n                  a_ccorr,\n                  color='red',\n                  marker='o',\n                  label='Model A', # add model set legend label\n                  fontsize=16)\n\ntaylor.add_model_set(b_sdev,\n                  b_ccorr,\n                  color='blue',\n                  marker='o',\n                  label='Model B',\n                  fontsize=16)\n\n# Add model name\ntaylor.add_model_name(var_list, fontsize=16)\n\n# Add figure legend\ntaylor.add_legend(fontsize=16)\n\n# Add constant centered RMS difference contours.\ntaylor.add_contours(levels=np.arange(0, 1.1, 0.25),\n                 colors='lightgrey',\n                 linewidths=0.5);\n\n","type":"content","url":"/notebooks/taylor-diagrams#plotting-multiple-variables","position":21},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Bias"},"type":"lvl2","url":"/notebooks/taylor-diagrams#plotting-bias","position":22},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Plotting Bias"},"content":"We can add another layer of information to the Taylor Diagram by changing the marker size and shape depending on a third variable. Most commonly this is done to demonstrate bias, a statistical definition of the difference between the observed and estimated values.\n\nWe do this by adding a bias_array kwarg to the add_model_set() method. Doing so necessitates removing the marker specification, since they are overriden with up or down arrows of varrying sizes. Bias values are in percentages.\n\nIndicate the meaning of these new bias symbols with a third legend with the call add_bias_legend().\n\n# Sample corresponding bias data.\n\n# Case A\na_bias = [2.7, -1.5, 17.31, -20.11, 12.5, 8.341, -4.7]  # bias (%)\n\n# Case B\nb_bias = [1.7, 2.5, -17.31, 20.11, 19.5, 7.341, 9.2]\n\n# Create figure and TaylorDiagram instance\nfig = plt.figure(figsize=(10, 10))\ntaylor = gv.TaylorDiagram(fig=fig, label='REF')\n\n# Draw diagonal dashed lines from origin to correlation values\n# Also enforces proper X-Y ratio\ntaylor.add_xgrid(np.array([0.6, 0.9]))\n\n# Add models to Taylor diagram\ntaylor.add_model_set(a_sdev,\n                  a_ccorr,\n                  percent_bias_on=True, # indicate marker and size to be plotted based on bias_array\n                  bias_array=a_bias, # specify bias array\n                  color='red',\n                  label='Model A',\n                  fontsize=16)\n\ntaylor.add_model_set(b_sdev,\n                  b_ccorr,\n                  percent_bias_on=True,\n                  bias_array=b_bias,\n                  color='blue',\n                  label='Model B',\n                  fontsize=16)\n\n# Add model name\ntaylor.add_model_name(var_list, fontsize=16)\n\n# Add figure legend\ntaylor.add_legend(fontsize=16)\n\n# Add bias legend\ntaylor.add_bias_legend()\n\n# Add constant centered RMS difference contours.\ntaylor.add_contours(levels=np.arange(0, 1.1, 0.25),\n                 colors='lightgrey',\n                 linewidths=0.5);\n\n","type":"content","url":"/notebooks/taylor-diagrams#plotting-bias","position":23},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Variants"},"type":"lvl2","url":"/notebooks/taylor-diagrams#variants","position":24},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Variants"},"content":"\n\nTaylor Diagram’s can be altered in the following variations (not all of which are supported yet by GeoCAT-viz, please consider this \n\nfeature request form). Coming soon:\n\nSupporting display of negative correlations by extending the diagram into a second quandrant to the left.\n\nSupporting automatic notations connecting related points, say the same variable in two different models to see how it moves towards truth.\n\n\n\n","type":"content","url":"/notebooks/taylor-diagrams#variants","position":25},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/taylor-diagrams#summary","position":26},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Summary"},"content":"Taylor Diagrams allow you to display and compare statistical information about several models, variables, ensembles, or other dataset categorizations on a single plot. They are commonly used in climate analysis. With these tools under your belt, you’re ready to include stronger data visualizations in your research.","type":"content","url":"/notebooks/taylor-diagrams#summary","position":27},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/taylor-diagrams#whats-next","position":28},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl3":"What’s next?","lvl2":"Summary"},"content":"Let’s look at the meteorology specialty plots \n\nSkew T Diagrams.\n\n","type":"content","url":"/notebooks/taylor-diagrams#whats-next","position":29},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/taylor-diagrams#resources-and-references","position":30},{"hierarchy":{"lvl1":"Taylor Diagrams","lvl2":"Resources and references"},"content":"Karl E. Taylor - “Summarizing multiple aspects of model performance in a single diagram”, AGU 2001\n\nPlotting with GeoCAT Tutorial\n\nNCL Graphics: Taylor Diagrams","type":"content","url":"/notebooks/taylor-diagrams#resources-and-references","position":31},{"hierarchy":{"lvl1":"Skew T Diagrams"},"type":"lvl1","url":"/notebooks/skewt","position":0},{"hierarchy":{"lvl1":"Skew T Diagrams"},"content":"","type":"content","url":"/notebooks/skewt","position":1},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/skewt#overview","position":2},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Overview"},"content":"Skew-T plots are effectively thermodynamic diagrams used in meteorology. They display data collected from radiosonde balloons collecting atmospheric data including pressure level, temperature, relative humidity, and wind speed and direction.\n\nIn this notebook, we’ll learn about the structural and data components of Skew-T diagrams and how to plot them in Python using the \n\nMetPy package.\n\nElements of a Skew-T Diagram\n\nAcquiring Sounding Data\n\nMaking a Skew-T plot in Python (with MetPy!)\n\n","type":"content","url":"/notebooks/skewt#overview","position":3},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/skewt#prerequisites","position":4},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nMetpy\n\nUseful\n\n\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/skewt#prerequisites","position":5},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Elements of a Skew-T Plot"},"type":"lvl2","url":"/notebooks/skewt#elements-of-a-skew-t-plot","position":6},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Elements of a Skew-T Plot"},"content":"Let’s start out by talking about the structural elements of a Skew-T plot.\n\nTemperature Lines are drawn at an angle up from the x-axis and are where the name “Skew-T” comes from.\n\nPressure Lines are horizontal from the y-axis, where pressure is plotted at a logarithmic scale.\n\nDry Adiabats: are lines of constant potential temperature as hypothetical air with no moisture content rises isentropically (with constant entropy).\n\nMoist Adiabats: are lines of constant equivalent potential temperature - the change in temperature of fully saturated air as it rises, undergoing cooling due to adiabatic expansion.\n\nMixing Ratio Lines: represent lines of constant mixing ratio, the mass of water vapor relative to the mass of dry air.\n\nOn all those structural elements, Skew-T plots have two lines plotted on them, air temperature and dew point. In this notebook, we’ll be plotting the air temperature in red and the dew point in blue.\n\nAdditionally, Skew-T plots have wind barbs. These describe the wind speed and direction at different pressure levels and are plotted on the right side of the diagram.\n\nTip\n\nFor a more detailed description and a cool interactive diagram, visit \n\nNOAA’s Skew-T page.\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nimport pandas as pd\n\nfrom metpy.plots import SkewT, Hodograph\nimport metpy.calc as mpcalc\nfrom metpy.units import units\n\n","type":"content","url":"/notebooks/skewt#elements-of-a-skew-t-plot","position":7},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Acquiring Sounding Data"},"type":"lvl2","url":"/notebooks/skewt#acquiring-sounding-data","position":8},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Acquiring Sounding Data"},"content":"If you want to get your own sounding data, run the following code in a new cell using the date and station of your choice:from datetime import datetime\nfrom siphon.simplewebservice.wyoming import WyomingUpperAir\n\ndate = datetime(2023, 7, 7, 0)\nstation = 'JAX'\ndf = WyomingUpperAir.request_data(date, station)\n\nWe’ve already done this for you and saved the data in a file, notebooks/data/jax_sounding.csv for you to use. We’ll use that file’s data for the rest of the notebook\n\ndf = pd.read_csv('data/jax_sounding.csv')\ndf\n\nh = df['height'].values\np = df['pressure'].values\nT = df['temperature'].values\nTd = df['dewpoint'].values\nu = df['u_wind'].values\nv = df['v_wind'].values\n\n","type":"content","url":"/notebooks/skewt#acquiring-sounding-data","position":9},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"type":"lvl2","url":"/notebooks/skewt#making-a-skew-t-plot-in-python-with-metpy","position":10},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"content":"So, all of that might seem a little abstract without a visual. We’re going to use MetPy’s SkewT module to make an actual Skew-T plot with the sounding data we downloaded earlier.\n\nFrom the \n\nMetPy documentation:\n\n“This class simplifies the process of creating Skew-T log-P plots in using matplotlib. It handles requesting the appropriate skewed projection, and provides simplified wrappers to make it easy to plot data, add wind barbs, and add other lines to the plots (e.g. dry adiabats)”","type":"content","url":"/notebooks/skewt#making-a-skew-t-plot-in-python-with-metpy","position":11},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Just the basics","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"type":"lvl3","url":"/notebooks/skewt#just-the-basics","position":12},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Just the basics","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"content":"To start with, let’s create a very minimal Skew-T plot with just the pressure and temperature lines under the sounding data.\n\n# make figure and `SkewT` object\nfig = plt.figure(figsize=(9, 9))\nskewt = SkewT(fig=fig, rotation=45)\n\n# plot sounding data\nskewt.plot(p, T, 'r')  # air temperature\nskewt.plot(p, Td, 'b')  # dew point\nskewt.plot_barbs(p[p >= 100], u[p >= 100], v[p >= 100])  # wind barbs\n\nLet’s talk break that down a bit.# make figure and `SkewT` object\nfig = plt.figure(figsize=(9, 9))\nskewt = SkewT(fig=fig, rotation=45)\n\nFirst, we made a new figure and used it to make a new skew-T plot. If you don’t provide a figure to SkewT, one will be created for you, but it’s useful to make the default figure size a bit larger for this tutorial.\n\nAdditionally, we’ve also set the rotation kwarg to be 45 degrees. This is the angle that the temperature lines will be drawn at. MetPy’s default is 30 degrees, but we’re going to use a more traditional 45 degrees for this tutorial.# plot sounding data\nskewt.plot(p, T, 'r') # air temperature\nskewt.plot(p, Td, 'b') # dew point\n\nFor air temperature and dew point, we can use the standard plot method. The SkewT object provides a wrapper around matplotlib’s plot method, and can be used in the same way. Note that even though pressure is on the y-axis, we still provide it as the first argument to plot because it is the independent variable.skewt.plot_barbs(p[p >= 100], u[p >= 100], v[p >= 100]) # wind barbs\n\nFinally, we use SkewT’s \n\nplot_barbs method to add the wind barbs to the right side of the plot. This is a wrapper around matplotlib’s \n\nbarbs method that applies the appropriate transformation and positions the barbs as expected for a Skew-T plot. Note that we only plot the wind barbs for pressure levels greater than 100 hPa. This is just to keep the wind barbs from extending off the plot.\n\nIn addition to the elements we have added specifically, you can see that the SkewT object also added some of the structural elements we discussed previously. By default, SkewT adds the horizontal pressure and skewed temperature lines.\n\n","type":"content","url":"/notebooks/skewt#just-the-basics","position":13},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Adding more structural elements","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"type":"lvl3","url":"/notebooks/skewt#adding-more-structural-elements","position":14},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Adding more structural elements","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"content":"Next, let’s add the rest of the structural elements to the plot.\n\n# make figure and `SkewT` object\nfig = plt.figure(figsize=(9, 9))\nskewt = SkewT(fig=fig, rotation=45)\n\n# plot sounding data\nskewt.plot(p, T, 'r') # air temperature\nskewt.plot(p, Td, 'b') # dew point\nskewt.plot_barbs(p[p >= 100], u[p >= 100], v[p >= 100])  # wind barbs\n\n# add dry adiabats, moist adiabats, and mixing ratio lines\nskewt.plot_dry_adiabats()\nskewt.plot_moist_adiabats()\nskewt.plot_mixing_lines()\n\n\nSimilarly to the plot_barbs command, the SkewT object provides convenient methods for adding the remaining structural elements to the plot.\n\nThe default appearance of these elements is:\n\nDry Adiabats: dashed red/pinkish lines with an alpha value of 0.5\n\nMoist Adiabats: dashed blue lines with an alpha value of 0.5\n\nMixing Ratio Lines: dashed green lines with an alpha value of 0.8\n\nThese defaults can be overwritten by providing additional keyword arguments to the methods.\n\n","type":"content","url":"/notebooks/skewt#adding-more-structural-elements","position":15},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Polishing the plot","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"type":"lvl3","url":"/notebooks/skewt#polishing-the-plot","position":16},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"Polishing the plot","lvl2":"Making a Skew-T plot in Python (with MetPy!)"},"content":"Now that we have all the structural elements on the plot, let’s make it look a little nicer. The previous plot has all the necessary information, but it’s a little cluttered and hard to read.\n\n# make figure and `SkewT` object\nfig = plt.figure(figsize=(8,12))\nskewt = SkewT(fig=fig)\nskewt.ax.set_ylim(1000, 10)\n\n# plot sounding data\nskewt.plot(p, T, 'r') # air temperature\nskewt.plot(p, Td, 'b') # dew point\nskewt.plot_barbs(p[::5], u[::5], v[::5]) # add a wind barb every fifth level\n\n# add dry adiabats, moist adiabats, and mixing ratio lines\nskewt.plot_dry_adiabats(linewidth=0.5)\nskewt.plot_moist_adiabats(linewidth=0.5)\nskewt.plot_mixing_lines(linewidth=0.5)\n\n# add axis and figure titles\nplt.title(df['station'][0] + ' ' + str(df['time'][0]))\nplt.xlabel('temperature (degC)')\nplt.ylabel('pressure (hPa)')\n\nHere, we’ve made the following changes:\n\nchanged the figsize to figsize=(8,12)\n\nremoved the rotation kwarg from the SkewT object to allow the upper air temp and dew point lines to be seen without being cut off or expanding the x-axis limits\n\nskewt.ax.set_ylim(1000, 10): sets the y-axis limits to 1000 hPa at the bottom and 10 hPa at the top to include the entire sounding\n\nskewt.plot_barbs(p[::5], u[::5], v[::5]): plots every fifth wind barb to reduce clutter, also removes limiting the wind barbs to pressure levels greater than 100 hPa\n\nreduced the linewidth of the dry adiabats, moist adiabats, and mixing ratio lines to 0.5\n\nadded axes labels\n\nadded a title including the station name and date of the sounding pulled from the data\n\n","type":"content","url":"/notebooks/skewt#polishing-the-plot","position":17},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Additional Skew-T Options"},"type":"lvl2","url":"/notebooks/skewt#additional-skew-t-options","position":18},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Additional Skew-T Options"},"content":"There are a few additional options that can be used to customize the appearance of the Skew-T plot that we haven’t covered here. For more information, check out the \n\nMetPy documentation.\n\nHere’s a few quick examples of some of those additional options:\n\nfig = plt.figure(figsize=(15, 4))\n\n# set up some subplots\nskewt_plots = []\nfor i in range(0,4):\n    skewt_plots.append(SkewT(fig=fig, subplot=(1,4,i+1), rotation=45))\n    skewt_plots[i].plot(p, T, 'r') # air temperature\n    skewt_plots[i].plot(p, Td, 'b') # dew point\n    skewt_plots[i].plot_barbs(p[::5], u[::5], v[::5], length=5, linewidth=0.5)\n    skewt_plots[i].plot_dry_adiabats(linewidth=0.5)\n    skewt_plots[i].plot_moist_adiabats(linewidth=0.5)\n    skewt_plots[i].plot_mixing_lines(linewidth=0.5)\n    skewt_plots[i].ax.set_xlabel('')\n    skewt_plots[i].ax.set_ylabel('')\n\n# calculate LCL and parcel profile\nlcl_p, lcl_t = mpcalc.lcl(p[0]*units.hPa, T[0]*units.degC, Td[0]*units.degC)\nlcl_prof = mpcalc.parcel_profile(p*units.hPa, T[0]*units.degC, Td[0]*units.degC).to('degC')\n\n\n# LCL and parcel profile skew-T\n# At what point an air parcel lifted as a dry parcel becomes saturated\nskewt_plots[0].ax.set_title('LCL and Parcel Profile')\nskewt_plots[0].plot(p, lcl_prof, 'k')\nskewt_plots[0].plot(lcl_p, lcl_t, 'ko') # Lifted Condensation Level\n\n\n# add constant temperature line at t=0\nskewt_plots[1].ax.set_title('Constant T Line at 0$^\\circ$C')\nskewt_plots[1].ax.axvline(0, color='k', ls='--')\n\n\n# shade CAPE and CIN\n# Area above and below the Level of Free Convection  (LFC) - where the temeprature line crosses the moist adiabat\n# Updraft energy for thunderstorms (CAPE) and energy needed for the storm to start (CIN)\nskewt_plots[2].ax.set_title('Shade CAPE and CIN')\nskewt_plots[2].plot(p, lcl_prof, 'k')\nskewt_plots[2].shade_cin(p*units.hPa, T*units.degC, lcl_prof, Td*units.degC)  # Convective INhibition\nskewt_plots[2].shade_cape(p*units.hPa, T*units.degC, lcl_prof) # Convective Available Potential Energy\n\n\n# Hodograph\n#  A line that connects the tips of wind vectors between two atmospheric heights\n# # Used for understanding wind sheer\nskewt_plots[3].ax.set_title('Hodograph')\nax_hod = inset_axes(skewt_plots[3].ax, '30%', '30%')\nhod = Hodograph(ax_hod, component_range=50)\nhod.add_grid(increment=10)\nhod.plot_colormapped(u, v, h)\n\n","type":"content","url":"/notebooks/skewt#additional-skew-t-options","position":19},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/skewt#summary","position":20},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Summary"},"content":"Skew-T plots are a useful tool for visualizing and understanding sounding data. Creating Skew-T plots in python might seem challenging given their unique structural characteristics, but MetPy’s SkewT module greatly simplifies the process.","type":"content","url":"/notebooks/skewt#summary","position":21},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/skewt#whats-next","position":22},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next up let’s discuss \n\nspaghetti plots.\n\n","type":"content","url":"/notebooks/skewt#whats-next","position":23},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/skewt#resources-and-references","position":24},{"hierarchy":{"lvl1":"Skew T Diagrams","lvl2":"Resources and references"},"content":"Wyoming Upper Air\n\nSiphon\n\nMetPy’s SkewT documentation\n\nNOAA’s JetStream’s \n\nSkew-T Plot page","type":"content","url":"/notebooks/skewt#resources-and-references","position":25},{"hierarchy":{"lvl1":"Spaghetti Plots"},"type":"lvl1","url":"/notebooks/spaghetti","position":0},{"hierarchy":{"lvl1":"Spaghetti Plots"},"content":"","type":"content","url":"/notebooks/spaghetti","position":1},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/spaghetti#overview","position":2},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Overview"},"content":"Spaghetti plots are a tool typically used to visualize movement. Essentially they are many line plots displayed on the same axes. By drawing the same path at different times or from different forecasts, we can see the patterns and chaos associated with the plotted variable.\n\nSpaghetti Hurricane Plot\n\nSpaghetti Contour Plot\n\n","type":"content","url":"/notebooks/spaghetti#overview","position":3},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/spaghetti#prerequisites","position":4},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nCartopy\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\nimport numpy as np\nimport xarray as xr\nimport datetime\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nimport matplotlib.pylab as pl\n\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\nimport geocat.viz as gv\nimport geocat.datafiles as gdf\n\nimport tropycal.tracks as tracks\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n","type":"content","url":"/notebooks/spaghetti#prerequisites","position":5},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Spaghetti Hurricane Plot"},"type":"lvl2","url":"/notebooks/spaghetti#spaghetti-hurricane-plot","position":6},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Spaghetti Hurricane Plot"},"content":"Visualizing the predicted path of an incoming hurricane is both complicated and important. There are many plots that meteorologists are trained to read, but when shared with the public can be confusing or alarming. There are strengths and weaknesses to each hurricane visualization approach. The cone of uncertainty, for example, is often misinterpreted to suggest the hurricane growth in time rather than widening of path possibilities. Spaghetti plots on the other hand, clearly show hurricane paths but show them as equal to each other.\n\nIn this example we will plot some forecasted paths from the 2012 North-Atlantic storm Hurricane Sandy. Each forecast is from the Global Ensemble Forecast System (GEFS) provided by the National Centers for Environmental Prediction at NOAA.\n\nWe’ll use the package \n\ntropycal to easily access HURDAT2 and IBTrACS reanalysis data and operational National Hurricane Center (NHC) Best Track data. tropycal has a lot of great features for real time hurricane visualization, but since this Cookbook is comparatively static we’re using a past hurricane and only using this package to access the data. Our plotting will be done with matplotlib and cartopy.\n\n","type":"content","url":"/notebooks/spaghetti#spaghetti-hurricane-plot","position":7},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Read in Data","lvl2":"Spaghetti Hurricane Plot"},"type":"lvl3","url":"/notebooks/spaghetti#read-in-data","position":8},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Read in Data","lvl2":"Spaghetti Hurricane Plot"},"content":"First, to grab our hurricane data from tropycal we need to specify a basin:\n\nbasin = tracks.TrackDataset(basin='north_atlantic')\n\nFind your storm by name and year:\n\nstorm = basin.get_storm(('sandy',2012))\n\nsandy_ds = storm.to_xarray()\nsandy_ds\n\nAnd we can grab any of a number of forecasts:\n\nforecasts = storm.get_operational_forecasts()\nprint(forecasts.keys())\n\nEach key represents a forecast model, we’ll select the GFS AP01 forecast which has many initializations. These initializations are named by time in YYYYMMDDHH format:\n\nforecasts_AP01 = forecasts['AP01']\nprint(forecasts_AP01.keys())\n\n","type":"content","url":"/notebooks/spaghetti#read-in-data","position":9},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of One Esemble Member","lvl2":"Spaghetti Hurricane Plot"},"type":"lvl3","url":"/notebooks/spaghetti#spaghetti-plot-of-one-esemble-member","position":10},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of One Esemble Member","lvl2":"Spaghetti Hurricane Plot"},"content":"Let’s set up our Cartopy grid to plot one ensemble member of the hurricane model.\n\nThese steps might be familiar to you but we:\n\ncreate our axes with a Plate Caree projection\n\nadd land features\n\nadd grid lines\n\nedit our gridline labels to not duplicate on all four sides\n\nedit our gridline label fontsize\n\n# Set up Cartopy Projection with land features\nax = plt.axes(projection=ccrs.PlateCarree())\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Add Gridlines to right and bottom\ngl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                  linewidth=.25, color='gray', alpha=0.5, linestyle='--')\ngl.xlabels_top = False\ngl.ylabels_left = False\ngl.xlabel_style = {'size': 8,}\ngl.ylabel_style = {'size': 8,}\n\nLooking at GFS Ensemble Member Forecast AP01, we can make a spaghetti plot of each of these initializations.\n\nThe crux of the visualization is that we loop through and plot each initialization (in for i in forecasts_AP01), plot the true hurricane path, and add a legend (plt.legend()).\n\n# Set up Cartopy Projection with land features\nax = plt.axes(projection=ccrs.PlateCarree())\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Add Gridlines to right and bottom\ngl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                  linewidth=.25, color='gray', alpha=0.5, linestyle='--')\ngl.xlabels_top = False\ngl.ylabels_left = False\ngl.xlabel_style = {'size': 8,}\ngl.ylabel_style = {'size': 8,}\n\n# Spaghetti Plot of AP01 forecasts\nforecasts_AP01 = forecasts['AP01']\nfor i in forecasts_AP01:\n    # We're naming this line even though it is over-written each loop,\n    # so that we can reference the last line in the legend\n    # (as they all share the same formatting)\n    forecast_path = plt.plot(forecasts_AP01[i]['lon'],\n                            forecasts_AP01[i]['lat'],\n                            color='cornflowerblue',\n                            linewidth=0.5)\n\n# Plot the real storm path in a thicker black line\ntrue_path = plt.plot(sandy_ds.lon,\n    sandy_ds.lat,\n    color='k',\n    linewidth=1) # Make it thicker than the ensemble paths\n\n# Add a legend with only one forecast_path and the true_path\nplt.legend([true_path[0], forecast_path[0]], ['True Path', 'GFS AP01 Forecasts'])\n\nplt.title('Hurricane Sandy (2012)');\n\nThis plot is a great example of a spaghetti plot, but is it super useful? Is it confusing? Each line looks like it carries the same weight, when some of these possible paths are from hours before Sandy hit the Northeastern United States and others are from days before.\n\nMaybe it is better to show the user some indication of how the forecast for this ensemble converged on the true path with later and later initialization times.\n\n","type":"content","url":"/notebooks/spaghetti#spaghetti-plot-of-one-esemble-member","position":11},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of One Esemble Member with Temporal Colormapping","lvl2":"Spaghetti Hurricane Plot"},"type":"lvl3","url":"/notebooks/spaghetti#spaghetti-plot-of-one-esemble-member-with-temporal-colormapping","position":12},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of One Esemble Member with Temporal Colormapping","lvl2":"Spaghetti Hurricane Plot"},"content":"Some additions to look out for:\n\nwe grab the time information from the initialization name using datetime\n\nnormalize a colormap by the time information with cmap = mpl.colors.ListedColormap(plt.cm.autumn_r(normalized_times))\n\nloop through the colormap as we loop through the time steps within the ensemble member\n\nadd a colorbar  with plt.colorbar(plt.cm.ScalarMappable(cmap=cmap)), where ScalarMappable is used to map scalar data to RGBA.\n\n# Set up Cartopy Projection with land features\nax = plt.axes(projection=ccrs.PlateCarree())\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Add Gridlines to right and bottom\ngl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                  linewidth=.25, color='gray', alpha=0.5, linestyle='--')\ngl.xlabels_top = False\ngl.ylabels_left = False\ngl.xlabel_style = {'size': 8,}\ngl.ylabel_style = {'size': 8,}\n\n# Spaghetti Plot of AP01 forecasts\nforecasts_AP01 = forecasts['AP01']\n\n# Get time information from initialization name\nformat = '%Y%m%d%H'\ntimes = [datetime.datetime.strptime(i, format) for i in list(forecasts_AP01.keys())]\nnormalized_times = [(i - times[0]) / (times[-1] - times[0]) for i in times]\n\n# Create a color list for forecast iteration\ncmap = mpl.colors.ListedColormap(plt.cm.autumn_r(normalized_times))\n\nc = 0\nfor i in forecasts_AP01:\n    plt.plot(forecasts_AP01[i]['lon'],\n        forecasts_AP01[i]['lat'],\n        color=cmap(c),\n        linewidth=0.5)\n    c += 1\n\n# Plot the real storm path\ntrue_path = plt.plot(sandy_ds.lon,\n    sandy_ds.lat,\n    color='red', # Selecting a color matching one of the cmap extremes\n    linewidth=1,\n    label='True Path') # The easiest way to add a plot to the legend is with the label kwarg\n\n# Add a legend with only one the true_path\n# Forecasted paths will be shown in a colorbar\nplt.legend()\n\nplt.title('Hurricane Sandy')\n\n# Add colorbar\ncbar = plt.colorbar(plt.cm.ScalarMappable(cmap=cmap), ax=ax, orientation='horizontal', shrink=0.8, pad=0.075)\ncbar.set_label('GFS AP01 Forecasts', labelpad=6)\n\n# Set tick locations and labels for every 4th tick\n# i.e. once a day (a new initialiation every 6 hours)\ntick_indices = range(0, len(times), 4)\ncbar.set_ticks([normalized_times[i] for i in tick_indices])\ncbar.set_ticklabels([times[i].strftime('%d') for i in tick_indices], fontsize=8)\ncbar.ax.text(1.02, 0.5, 'OCT-2012', va='top', ha='left', transform=cbar.ax.transAxes);\n\nNow we can see that as the storm progressed, the AP01 GFS Forecast Ensemble Member converges on Sandy’s true path as the storm progresses through October, 2012.\n\nAlternatively, we may want to plot the possible hurricane paths from multiple GFS Forecast Ensemble members from the same iteration timestamp as a spaghetti plot.\n\n","type":"content","url":"/notebooks/spaghetti#spaghetti-plot-of-one-esemble-member-with-temporal-colormapping","position":13},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of All Esemble Members at One Point in Time","lvl2":"Spaghetti Hurricane Plot"},"type":"lvl3","url":"/notebooks/spaghetti#spaghetti-plot-of-all-esemble-members-at-one-point-in-time","position":14},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Spaghetti Plot of All Esemble Members at One Point in Time","lvl2":"Spaghetti Hurricane Plot"},"content":"First, we need to grab all of the relevant forecast keys to GFS models (the ones that are titled AP## from 0 to 20):\n\n# List of valid AP## keys from 0 to 20\nGFS_keys = ['AP' + str(i).zfill(2) for i in range(1, 21)]\n\n# Arbitrarily selected midnight on October 27, 2012 to plot all forecasts at\ntime = '2012102700'\n\n# Set up Cartopy Projection with land features\nax = plt.axes(projection=ccrs.PlateCarree())\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Add Gridlines to right and bottom\ngl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,\n                  linewidth=.25, color='gray', alpha=0.5, linestyle='--')\ngl.xlabels_top = False\ngl.ylabels_left = False\ngl.xlabel_style = {'size': 8,}\ngl.ylabel_style = {'size': 8,}\n\n# Spaghetti Plot of forecasts\nfor i in range(20):\n    ap = forecasts[GFS_keys[i]]\n    forecast_path = plt.plot(ap[time]['lon'],\n        ap[time]['lat'],\n        color='cornflowerblue',\n        linewidth=0.5)\n\n# Plot the real storm path in a thicker black line\ntrue_path = plt.plot(sandy_ds.lon, sandy_ds.lat, color='k', linewidth=1)\n\n# Add a legend with only one forecast_path and the true_path\nplt.legend([true_path[0], forecast_path[0]],\n    ['True Path', 'AP01 - AP20'],\n    loc='lower right')\n\nplt.title('Hurricane Sandy - GFS Forecasts from Oct-27-2012');\n\nHurricane Sandy hit the Northeast on October 29, 2012. From this spaghetti plot we can see that by the 27th most ensemble members of the GFS forecast predicted a similar behavior for the storm.\n\nThere is more analysis that could be done on hurriane trajectories. We have covered some plotting customization that might be useful for your analysis and data visualization.\n\n","type":"content","url":"/notebooks/spaghetti#spaghetti-plot-of-all-esemble-members-at-one-point-in-time","position":15},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Spaghetti Contour Plot"},"type":"lvl2","url":"/notebooks/spaghetti#spaghetti-contour-plot","position":16},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Spaghetti Contour Plot"},"content":"\n\nIn this example we will read in the geopotential height datafile HGT500_MON_1958-1997.nc from using geocat-datafiles. Then we will look at different timesteps of the HGT geopotential height variable at the 5500 gpm level, plotting this contour’s locations through time. This example is adapted from \n\nGeoCAT’s \n\nNCL_conOncon_5 script.\n\n","type":"content","url":"/notebooks/spaghetti#spaghetti-contour-plot","position":17},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Read in data:","lvl2":"Spaghetti Contour Plot"},"type":"lvl3","url":"/notebooks/spaghetti#read-in-data-1","position":18},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Read in data:","lvl2":"Spaghetti Contour Plot"},"content":"\n\nds = xr.open_dataset(gdf.get(\"netcdf_files/HGT500_MON_1958-1997.nc\"),\n                     decode_times=False)\n\nds\n\n","type":"content","url":"/notebooks/spaghetti#read-in-data-1","position":19},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Initial Spaghetti Plot on North Polar Stereographic Projection","lvl2":"Spaghetti Contour Plot"},"type":"lvl3","url":"/notebooks/spaghetti#initial-spaghetti-plot-on-north-polar-stereographic-projection","position":20},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Initial Spaghetti Plot on North Polar Stereographic Projection","lvl2":"Spaghetti Contour Plot"},"content":"Again, first let’s set up our Cartopy axes. This time setting our projection to NorthPolarStereo.\n\n# Set up Cartopy Map Projection\nfig = plt.figure(figsize=(8, 8))\nax = plt.axes(projection=ccrs.NorthPolarStereo())\n\ngv.set_map_boundary(ax, [-180, 180], [0, 40], south_pad=1)\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Set draw_labels to False so that we can manually manipulate it\ngl = ax.gridlines(ccrs.PlateCarree(),\n                  draw_labels=False,\n                  linestyle=\"--\",\n                  linewidth=1,\n                  color='darkgray',\n                  zorder=2)\n\nThen let’s add our data to this plot.\n\nWe will iterate through every 12th timestep\n\nhandling any artifacts of the global wrapping at 0 or 360 degrees with gv.xr_add_cyclic_longitudes(p, \"lon\")\n\nand calling a contour plot on a single level.\n\n# Set up Cartopy Map Projection\nfig = plt.figure(figsize=(8, 8))\nax = plt.axes(projection=ccrs.NorthPolarStereo())\n\ngv.set_map_boundary(ax, [-180, 180], [0, 40], south_pad=1)\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Set draw_labels to False so that we can manually manipulate it\ngl = ax.gridlines(ccrs.PlateCarree(),\n                  draw_labels=False,\n                  linestyle=\"--\",\n                  linewidth=1,\n                  color='darkgray',\n                  zorder=2)\n\n# Iterate through the 19 timesteps, plotting the data\nn = 19\nfor x in range(n):\n\n    # Get a slice of data at the 12*x timestep\n    p = ds.HGT.isel(time=12*x)\n\n    # Use geocat-viz utility function to handle the no-shown-data artifact\n    # of 0 and 360-degree longitudes\n    slon = gv.xr_add_cyclic_longitudes(p, \"lon\")\n\n    # Plot contour data at pressure level 5500 for the 12*x timestep\n    p = slon.plot.contour(ax=ax,\n                          transform=ccrs.PlateCarree(),\n                          linewidths=0.5,\n                          levels=[5500],\n                          colors='blue',\n                          add_labels=False)\n\n","type":"content","url":"/notebooks/spaghetti#initial-spaghetti-plot-on-north-polar-stereographic-projection","position":21},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Adding Directional Labels to Polar Stereographic Projection","lvl2":"Spaghetti Contour Plot"},"type":"lvl3","url":"/notebooks/spaghetti#adding-directional-labels-to-polar-stereographic-projection","position":22},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Adding Directional Labels to Polar Stereographic Projection","lvl2":"Spaghetti Contour Plot"},"content":"Adding labels to a map projection that aren’t lat/lon coordinates is less than intuitive. In this example we manually add labels and select their locations so that you can see NESW labels.\n\nFor this we use mticker.FixedLocator() to manipulare gridline spacing, manipulate East and West tick labels separately, and specify tick locations with ax.text(transform=ccrs.Geodetic()).\n\n# Generate a figure\nfig = plt.figure(figsize=(8, 8))\n\n# Create an axis with a polar stereographic projection\nax = plt.axes(projection=ccrs.NorthPolarStereo())\n\n# Add land feature to map\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Set map boundary to include latitudes between 0 and 40 and longitudes\n# between -180 and 180 only\ngv.set_map_boundary(ax, [-180, 180], [0, 40], south_pad=1)\n\n# Set draw_labels to False so that you can manually manipulate it later\ngl = ax.gridlines(ccrs.PlateCarree(),\n                  draw_labels=False,\n                  linestyle=\"--\",\n                  linewidth=1,\n                  color='darkgray',\n                  zorder=2)\n\n# Manipulate latitude and longitude gridline numbers and spacing\ngl.ylocator = mticker.FixedLocator(np.arange(0, 90, 15))\ngl.xlocator = mticker.FixedLocator(np.arange(-180, 180, 30))\n\n# Manipulate longitude labels (0, 30 E, 60 E, ..., 30 W, etc.)\nticks = np.arange(0, 210, 30)\netick = ['0'] + [\n    r'%dE' % tick for tick in ticks if (tick != 0) & (tick != 180)\n] + ['180']\nwtick = [r'%dW' % tick for tick in ticks if (tick != 0) & (tick != 180)]\nlabels = etick + wtick\nxticks = np.arange(0, 360, 30)\nyticks = np.full_like(xticks, -5)  # Latitude where the labels will be drawn\nfor xtick, ytick, label in zip(xticks, yticks, labels):\n    if label == '180':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='top',\n                transform=ccrs.Geodetic())\n    elif label == '0':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='bottom',\n                transform=ccrs.Geodetic())\n    else:\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='center',\n                transform=ccrs.Geodetic())\n\n# Iterate through 18 different timesteps\nfor x in range(19):\n\n    # Get a slice of data at the 12*x+1 timestep\n    p = ds.HGT.isel(time=12 * x + 1)\n\n    # Use geocat-viz utility function to handle the no-shown-data artifact\n    # of 0 and 360-degree longitudes\n    slon = gv.xr_add_cyclic_longitudes(p, \"lon\")\n\n    # Plot contour data at pressure level 5500 for the 12*x+1 timestep\n    p = slon.plot.contour(ax=ax,\n                          transform=ccrs.PlateCarree(),\n                          linewidths=0.5,\n                          levels=[5500],\n                          colors='blue',\n                          add_labels=False)\n\n# Use geocat.viz.util convenience function to add titles\ngv.set_titles_and_labels(ax,\n                         maintitle=r\"$\\bf{Spaghetti}$\" + \" \" + r\"$\\bf{Plot}$\",\n                         lefttitle=slon.long_name,\n                         righttitle='5500 '+slon.units)\n\n# Make tight layout\nplt.tight_layout()\n\nNow in this example, there isn’t necessarily a temporal progression of geopotential height, but to be sure let’s add a colormap component to each of our loops.\n\nThis is also useful because for your data visualization application there might be, and the commands are slightly different for a contour plot as for a line plot in the above example.\n\n","type":"content","url":"/notebooks/spaghetti#adding-directional-labels-to-polar-stereographic-projection","position":23},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Contour Spaghetti Plot Temporal Colorbar Manipulation","lvl2":"Spaghetti Contour Plot"},"type":"lvl3","url":"/notebooks/spaghetti#contour-spaghetti-plot-temporal-colorbar-manipulation","position":24},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Contour Spaghetti Plot Temporal Colorbar Manipulation","lvl2":"Spaghetti Contour Plot"},"content":"Let’s update add a discrete colorbar that has yearly ticklabels. One challenge addressed in this example is setting the ticklabels to be in the center of each discrete color box.\n\nNew code lines here are:\n\ncreating a discrete colormap with plt.get_cmap('winter_r', n) and color bounds with np.linspace()\n\nspecifying the color in each contour call with colors=[cmap(bounds)[x]]\n\nadjusting the time unit for the colorbar ticks\n\nadding a colorbar for the normalized colormap, calling the orientation, shrink, and pad keyword arguments to make it display well\n\nsetting colorbar tick location to be at color midpoints with cbar.set_ticks(), yet forcing their labels to be years (not year midpoints) with cbar.set_ticklabels()\n\n# Set up Cartopy Map Projection\nfig = plt.figure(figsize=(8, 8))\nax = plt.axes(projection=ccrs.NorthPolarStereo())\n\ngv.set_map_boundary(ax, [-180, 180], [0, 40], south_pad=1)\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Set draw_labels to False so that we can manually manipulate it\ngl = ax.gridlines(ccrs.PlateCarree(),\n                  draw_labels=False,\n                  linestyle=\"--\",\n                  linewidth=1,\n                  color='darkgray',\n                  zorder=2)\n\n# Manipulate latitude and longitude gridline numbers and spacing\ngl.ylocator = mticker.FixedLocator(np.arange(0, 90, 15))\ngl.xlocator = mticker.FixedLocator(np.arange(-180, 180, 30))\n\n# Manipulate longitude labels (0, 30 E, 60 E, ..., 30 W, etc.)\nticks = np.arange(0, 210, 30)\netick = ['0'] + [\n    r'%dE' % tick for tick in ticks if (tick != 0) & (tick != 180)\n] + ['180']\nwtick = [r'%dW' % tick for tick in ticks if (tick != 0) & (tick != 180)]\nlabels = etick + wtick\nxticks = np.arange(0, 360, 30)\nyticks = np.full_like(xticks, -5)  # Latitude where the labels will be drawn\nfor xtick, ytick, label in zip(xticks, yticks, labels):\n    if label == '180':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='top',\n                transform=ccrs.Geodetic())\n    elif label == '0':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='bottom',\n                transform=ccrs.Geodetic())\n    else:\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='center',\n                transform=ccrs.Geodetic())\n\n# Create a color list for each of the 19 contours\nn = 19\ncmap = plt.get_cmap('winter_r', n) # the `, n` makes the colormap display discretized\nbounds = np.linspace(0, 1, n)\n\n# Iterate through the timesteps\nfor x in range(n):\n\n    # Get a slice of data at the 12*x timestep\n    p = ds.HGT.isel(time=12*x)\n\n    # Handle wrapping artifacts\n    slon = gv.xr_add_cyclic_longitudes(p, \"lon\")\n\n    # Plot contour data at pressure level 5500 for the 12*x timestep\n    p = slon.plot.contour(ax=ax,\n                          transform=ccrs.PlateCarree(),\n                          linewidths=0.5,\n                          levels=[5500],\n                          colors=[cmap(bounds)[x]], # set colors to use our new cmap\n                          add_labels=False)\n\n# Add a colorbar\n# The default time unit is in months since 1958, years is more intuitive\nyear_0 = 1958\nyear_n = (ds.time.isel(time=12*n) / 12).astype(int) + year_0\n\nnorm = plt.Normalize(vmin=year_0, vmax=year_n)\ncbar = plt.colorbar(plt.cm.ScalarMappable(cmap=cmap, norm=norm),\n    ax=ax,\n    orientation='vertical',\n    shrink=0.8, # Shrink to the approximate size of the map\n    pad = 0.1) # Pad so colorbar doesn't overlap with directional label\n\ncbar.set_ticks(np.arange(year_0+0.5, year_n)) # Set tick locations to be at color midpoints\ncbar.set_ticklabels(np.arange(year_0, year_n)) # Set tick labels to be years (despite their location value being year + 0.5)\ncbar.set_label('Time (years)')\n\n# Use geocat.viz.util convenience function to add titles\ngv.set_titles_and_labels(ax,\n                         maintitle=r\"$\\bf{Spaghetti}$\" + \" \" + r\"$\\bf{Plot}$\",\n                         lefttitle=slon.long_name,\n                         righttitle='5500 '+slon.units)\n\n# Make tight layout\nplt.tight_layout();\n\n","type":"content","url":"/notebooks/spaghetti#contour-spaghetti-plot-temporal-colorbar-manipulation","position":25},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Contour Spaghetti Plot with Hand-Picked Colors","lvl2":"Spaghetti Contour Plot"},"type":"lvl3","url":"/notebooks/spaghetti#contour-spaghetti-plot-with-hand-picked-colors","position":26},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"Contour Spaghetti Plot with Hand-Picked Colors","lvl2":"Spaghetti Contour Plot"},"content":"If you want your plot to be visually appealing it might be worth selecting different colors for each contour plot in the for-loop, however these do not have to be sequentially ordered or time-aware. It is actually simplest to hand-pick colors for each loop. In this iteration of the plot we hand pick colors in a colorlist and plot the first time step on its own to demonstrate plotting one loop unlike the others.\n\n# Generate a figure\nfig = plt.figure(figsize=(8, 8))\n\n# Create an axis with a polar stereographic projection\nax = plt.axes(projection=ccrs.NorthPolarStereo())\n\n# Add land feature to map\nax.add_feature(cfeature.LAND, facecolor='lightgray')\n\n# Set map boundary to include latitudes between 0 and 40 and longitudes\n# between -180 and 180 only\ngv.set_map_boundary(ax, [-180, 180], [0, 40], south_pad=1)\n\n# Set draw_labels to False so that you can manually manipulate it later\ngl = ax.gridlines(ccrs.PlateCarree(),\n                  draw_labels=False,\n                  linestyle=\"--\",\n                  linewidth=1,\n                  color='darkgray',\n                  zorder=2)\n\n# Manipulate latitude and longitude gridline numbers and spacing\ngl.ylocator = mticker.FixedLocator(np.arange(0, 90, 15))\ngl.xlocator = mticker.FixedLocator(np.arange(-180, 180, 30))\n\n# Manipulate longitude labels (0, 30 E, 60 E, ..., 30 W, etc.)\nticks = np.arange(0, 210, 30)\netick = ['0'] + [\n    r'%dE' % tick for tick in ticks if (tick != 0) & (tick != 180)\n] + ['180']\nwtick = [r'%dW' % tick for tick in ticks if (tick != 0) & (tick != 180)]\nlabels = etick + wtick\nxticks = np.arange(0, 360, 30)\nyticks = np.full_like(xticks, -5)  # Latitude where the labels will be drawn\nfor xtick, ytick, label in zip(xticks, yticks, labels):\n    if label == '180':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='top',\n                transform=ccrs.Geodetic())\n    elif label == '0':\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='bottom',\n                transform=ccrs.Geodetic())\n    else:\n        ax.text(xtick,\n                ytick,\n                label,\n                fontsize=12,\n                horizontalalignment='center',\n                verticalalignment='center',\n                transform=ccrs.Geodetic())\n\n# Get slice of data at the 0th timestep - plot this contour line separately\n# because it will be thicker than the other contour lines\np = ds.HGT.isel(time=0)\n\n# Use geocat-viz utility function to handle the no-shown-data\n# artifact of 0 and 360-degree longitudes\nslon = gv.xr_add_cyclic_longitudes(p, \"lon\")\n\n# Plot contour data at pressure level 5500 at the first timestep\np = slon.plot.contour(ax=ax,\n                      transform=ccrs.PlateCarree(),\n                      linewidths=1.5,\n                      levels=[5500],\n                      colors='black',\n                      add_labels=False)\n\n# Create a color list for each of the next 18 contours\ncolorlist = [\n    \"crimson\", \"green\", \"blue\", \"yellow\", \"cyan\", \"hotpink\", \"crimson\",\n    \"skyblue\", \"navy\", \"lightyellow\", \"mediumorchid\", \"orange\", \"slateblue\",\n    \"palegreen\", \"magenta\", \"springgreen\", \"pink\", \"forestgreen\", \"violet\"\n]\n\n# Iterate through 18 different timesteps\nfor x in range(18):\n\n    # Get a slice of data at the 12*x+1 timestep\n    p = ds.HGT.isel(time=12 * x + 1)\n\n    # Use geocat-viz utility function to handle the no-shown-data artifact\n    # of 0 and 360-degree longitudes\n    slon = gv.xr_add_cyclic_longitudes(p, \"lon\")\n\n    # Plot contour data at pressure level 5500 for the 12*x+1 timestep\n    p = slon.plot.contour(ax=ax,\n                          transform=ccrs.PlateCarree(),\n                          linewidths=0.5,\n                          levels=[5500],\n                          colors=colorlist[x],\n                          add_labels=False)\n\n# Use geocat.viz.util convenience function to add titles\ngv.set_titles_and_labels(ax,\n                         maintitle=r\"$\\bf{Spaghetti}$\" + \" \" + r\"$\\bf{Plot}$\",\n                         lefttitle=slon.long_name,\n                         righttitle='5500 '+slon.units)\n\n# Make tight layout\nplt.tight_layout()\n\n\n\n","type":"content","url":"/notebooks/spaghetti#contour-spaghetti-plot-with-hand-picked-colors","position":27},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/spaghetti#summary","position":28},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Summary"},"content":"Spaghetti plots are many lines drawn on the same figure. They have pros and cons. They are visually stunning but can be confusing, so it is important to make sure your data visualization conveys accurate information either by manipulating color or linewidth. Since the manipulation of spaghetti plots have their own considerations, this chapter shows several design choices that you can use to jumpstart your visualization needs.","type":"content","url":"/notebooks/spaghetti#summary","position":29},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/spaghetti#whats-next","position":30},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next up let’s discuss \n\nAnimation.\n\n","type":"content","url":"/notebooks/spaghetti#whats-next","position":31},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/spaghetti#resources-and-references","position":32},{"hierarchy":{"lvl1":"Spaghetti Plots","lvl2":"Resources and references"},"content":"Tropycal documentation\n\nGeoCat-examples visualization gallery\n\nGeoCAT-viz documentation","type":"content","url":"/notebooks/spaghetti#resources-and-references","position":33},{"hierarchy":{"lvl1":"Animation"},"type":"lvl1","url":"/notebooks/animation","position":0},{"hierarchy":{"lvl1":"Animation"},"content":"","type":"content","url":"/notebooks/animation","position":1},{"hierarchy":{"lvl1":"Animation","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/animation#overview","position":2},{"hierarchy":{"lvl1":"Animation","lvl2":"Overview"},"content":"Animations can be a useful and effective tool to visualize data, especially when that data changes over time. In this notebook, we will explore how to create animations using the matplotlib library.\n\nWe will cover the two methods for creating animations in matplotlib, how to set up the elements of both types of animation, how to show the animation in jupyter notebooks, and how to save the animation to a file.\n\nAnimation fundamentals with matplotlib\n\nArtist Animation\n\nFunction Animation\n\n","type":"content","url":"/notebooks/animation#overview","position":3},{"hierarchy":{"lvl1":"Animation","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/animation#prerequisites","position":4},{"hierarchy":{"lvl1":"Animation","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nMatplotlib\n\nNecessary\n\n\n\nCartopy\n\nUseful\n\nNot necessary for animations in general, but useful for the examples in this notebook\n\nTime to learn: 10 minutes\n\nimport cartopy.crs as ccrs\nimport matplotlib.animation as animation\nimport xarray as xr\nfrom matplotlib import pyplot as plt\nimport os\nfrom PIL import Image\n\nimport geocat.datafiles as gdf\n\n","type":"content","url":"/notebooks/animation#prerequisites","position":5},{"hierarchy":{"lvl1":"Animation","lvl2":"Animation fundamentals with matplotlib"},"type":"lvl2","url":"/notebooks/animation#animation-fundamentals-with-matplotlib","position":6},{"hierarchy":{"lvl1":"Animation","lvl2":"Animation fundamentals with matplotlib"},"content":"There are two different methods of creating animations with matplotlib:\n\nArtist animations pulls from a list of pre-made \n\nartists to draw in each frame to produce an animation\n\nFunction animation iteratively modifies data on a pre-existing figure to produce an animation\n\nGenerally, function animation is easier to use, but artist animation can be more flexible for certain applications. We’ll cover both methods in this notebook.\n\n","type":"content","url":"/notebooks/animation#animation-fundamentals-with-matplotlib","position":7},{"hierarchy":{"lvl1":"Animation","lvl3":"Animating within jupyter notebooks","lvl2":"Animation fundamentals with matplotlib"},"type":"lvl3","url":"/notebooks/animation#animating-within-jupyter-notebooks","position":8},{"hierarchy":{"lvl1":"Animation","lvl3":"Animating within jupyter notebooks","lvl2":"Animation fundamentals with matplotlib"},"content":"Before we get into either type of animation, we’re going to alter \n\nmatplotlib’s runtime configuration settings (or rcParams) to allow us to use matplotlib’s animation functions within jupyter notebooks. This next cell is not necessary if you want to create animations in a script or just want to save the animation to a file.\n\nHere, we’re changing default animation html output setting to \"jshtml\", which creates a JavaScript animation that can be displayed in a jupyter notebook. The default setting is \"none\".\n\nplt.rcParams[\"animation.html\"] = \"jshtml\"\n\n","type":"content","url":"/notebooks/animation#animating-within-jupyter-notebooks","position":9},{"hierarchy":{"lvl1":"Animation","lvl2":"Artist Animation"},"type":"lvl2","url":"/notebooks/animation#artist-animation","position":10},{"hierarchy":{"lvl1":"Animation","lvl2":"Artist Animation"},"content":"Artist animation uses pre-made artists to cycle through to produce an animation.\n\nIn this example, we’re going to plot images using matplotlib’s \n\nimshow function and save the resulting artist object to a list. Then, we’ll use the \n\nArtistAnimation function to create an animation from that list of artists.","type":"content","url":"/notebooks/animation#artist-animation","position":11},{"hierarchy":{"lvl1":"Animation","lvl3":"Data","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#data","position":12},{"hierarchy":{"lvl1":"Animation","lvl3":"Data","lvl2":"Artist Animation"},"content":"Before we get into those steps, let’s get some images to animate. First, we’ll be looking at some \n\nGeoColor satellite imagery from \n\nGOES-16.\n\nIn this repository, there is a script, notebooks/scripts/goes_getter.py, that will download hourly images from the last 24 hours from the \n\nGOES-16 archive if you’d like to play around with this yourself. We have already downloaded some images for this example in the notebooks/data/goes16_hr/ directory and will be using those for this part of the notebook.\n\n","type":"content","url":"/notebooks/animation#data","position":13},{"hierarchy":{"lvl1":"Animation","lvl3":"Get the images into a list","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#get-the-images-into-a-list","position":14},{"hierarchy":{"lvl1":"Animation","lvl3":"Get the images into a list","lvl2":"Artist Animation"},"content":"First, we need to ge the images from the directory into a list. We know the only files in this directory are the images we want to plot, so let’s get get a list of all the files ending in .jpg from that path using os.listdir().\n\nWe’ll also sort them using the built in sorted function to make sure that our list of images ends up in chronological order.\n\nim_dir = \"./data/goes16_hr/\"\nim_paths = sorted([p for p in os.listdir(im_dir) if p.endswith(\".jpg\")])\n\n","type":"content","url":"/notebooks/animation#get-the-images-into-a-list","position":15},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the figure","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-figure","position":16},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the figure","lvl2":"Artist Animation"},"content":"Now, we need to set up the figure we’ll be plotting our animation on.\n\nNote\n\nRunning the next cell will produce a blank figure in the jupyter notebook. This is expected since we’ve only created a blank figure to plot on, but haven’t actually plotted anything yet.\n\ndpi = 100\nfigsize = tuple(t / dpi for t in Image.open(im_dir + im_paths[0]).size)\nfig = plt.figure(figsize=figsize, dpi=dpi)\nax = fig.add_axes([0, 0, 1, 1])  # span the whole figure\nax.set_axis_off()\n\nFirst, we set out dpi to be 100. This is technically not necessary at this point in creating the animation, but we’re going to use it to set the size of the figure. Since we’re plotting images, we want to make sure that the figure size is the same size as the images we’re plotting.\n\nNext, we’re going to figure out what our figsize should be based on the dpi and the size of the images we’re about to plot. tuple(t / dpi for t in Image.open(im_dir + im_paths[0]).size) divides each dimension of the size of the image by the intended dpi and then returns the result as a tuple. We then use that tuple to create our figsize.\n\nNext, we create the figure using plt.figure() and the figsize and dpi we just calculated.\n\nThen, we create the axes object using fig.add_axes([0, 0, 1, 1]). This adds axes to our figure that span the entire range of the figure, allowing the images plot on these axes to take up the entire figure space.\n\nFinally, we turn off the axes using ax.axis(\"off\"). This is because we don’t want to see axes on our final image plot.\n\nTip\n\nCustomizing the figure size, dpi, and axes is not necessary for creating an artist animation, but it will make our end result look nicer.\n\n","type":"content","url":"/notebooks/animation#creating-the-figure","position":17},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating a list of artists","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#creating-a-list-of-artists","position":18},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating a list of artists","lvl2":"Artist Animation"},"content":"Now that we have a list of the filepaths for all the images we want to plot and axes to plot them on, we can use imshow to plot each image and save the resulting artist object to a list.\n\nims = [[ax.imshow(Image.open(im_dir + im_path), animated=True)] for im_path in im_paths]\n\nA couple of things to note here:\n\nYou may notice that we’re using list generation to create our final list, ims. But what might not be obvious is that we’re actually making a list of lists. Each created implot object is put into its own one-item list, and then all of those lists are used to create ims. This is because ArtistAnimation expects a list of lists, where each inner list is a list of artists to be plotted in a single frame.\n\nWe’re using a kwarg you may not have seen before using imshow: animated=True. This allows the artist to only be drawn when called as part of an animation. This is a kwarg that is common to all artist objects.\n\n","type":"content","url":"/notebooks/animation#creating-a-list-of-artists","position":19},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the artist animation","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-artist-animation","position":20},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the artist animation","lvl2":"Artist Animation"},"content":"Now that we’ve set up our figure and list (of lists) of artists, we can create the animation using ArtistAnimation.\n\nani = animation.ArtistAnimation(fig, ims, interval=150, repeat_delay=1000)\n\nArtistAnimation takes two required arguments:\n\nthe figure to plot on (fig in our case) and\n\nthe list of pre-created artist objects (ims) to plot.\n\nWe’ve also provided a few optional arguments:\n\ninterval: The time between frames in milliseconds. We’ve set this to 150 milliseconds, or 0.15 seconds.\n\nrepeat_delay: The time in milliseconds to wait before repeating the animation. We’ve set this to 1000 milliseconds, or 1 second.\n\nAnd that’s it! We’ve created an animation in matplotlib using artist animation. Let’s take a look at it.\n\nani\n\n","type":"content","url":"/notebooks/animation#creating-the-artist-animation","position":21},{"hierarchy":{"lvl1":"Animation","lvl3":"Saving the animation","lvl2":"Artist Animation"},"type":"lvl3","url":"/notebooks/animation#saving-the-animation","position":22},{"hierarchy":{"lvl1":"Animation","lvl3":"Saving the animation","lvl2":"Artist Animation"},"content":"If displaying your animation in a jupyter notebook was your end goal, then you’re done! But if you want to save your animation to a file for later use, you can use the save method of the ArtistAnimation object.\n\nani.save(\"goes16_hr.gif\")\n\n","type":"content","url":"/notebooks/animation#saving-the-animation","position":23},{"hierarchy":{"lvl1":"Animation","lvl2":"Function animation"},"type":"lvl2","url":"/notebooks/animation#function-animation","position":24},{"hierarchy":{"lvl1":"Animation","lvl2":"Function animation"},"content":"The steps for function animation in matplotlib are:\n\nSet up all the artists that will be used in the animation and the initial frame of the animation\n\nCreate a function that updates the data in the plot to create each frame of the animation\n\nCreate a FuncAnimation object with the the previously created elements\n\nDisplay and save the animation\n\n","type":"content","url":"/notebooks/animation#function-animation","position":25},{"hierarchy":{"lvl1":"Animation","lvl3":"Data","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#data-1","position":26},{"hierarchy":{"lvl1":"Animation","lvl3":"Data","lvl2":"Function animation"},"content":"For this example, we’re going to be looking at sample surface temperature data from our sample data repository, \n\ngeocat-datafiles.\n\nds = xr.open_dataset(gdf.get(\"netcdf_files/meccatemp.cdf\"))\nt = ds.t\n\n","type":"content","url":"/notebooks/animation#data-1","position":27},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the figure","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-figure-1","position":28},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the figure","lvl2":"Function animation"},"content":"The first step in creating a function animation is to create the figure that will be used to plot the animation.\n\nSince we’re working with data represented by latitude and longitude coordinates, we’re going to set up our figure and axes using \n\ncartopy.\n\n# Set up Axes with Cartopy Projection\nfig = plt.figure()\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n\nJust like before, we used plt.figure() to create the figure. Then, we used plt.axes with the projection kwarg set to ccrs.PlateCarree() to create the axes object. This sets up the axes to use the \n\nPlate Carree projection.\n\nFinally, we used ax.coastlines() to add coastlines to the plot.\n\n","type":"content","url":"/notebooks/animation#creating-the-figure-1","position":29},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the initial frame","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-initial-frame","position":30},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the initial frame","lvl2":"Function animation"},"content":"Now that we have our figure and axes set up, we can plot the initial frame of our animation.\n\nvmin = t.min().values\nvmax = t.max().values\nlevels = 30\n\n# create initial plot that we will update\nt[0, :, :].plot.contourf(\n    ax=ax,\n    transform=ccrs.PlateCarree(),\n    vmin=vmin,\n    vmax=vmax,\n    levels=levels,\n    cmap=\"inferno\",\n    cbar_kwargs={\n        \"location\": \"bottom\",\n    },\n)\n\nIn addition to plotting the initial frame, we also set up the colorbar. In order for every frame of the animation to use the same colorbar, we need to create the colorbar before we create the animation.\n\nThe vmin and vmax arguments of plt.contourf are set to the minimum and maximum values of the data, instead of each individual time slice. This ensures that the colorbar remains consistent across all frames of the animation. We also set a levels kwarg to similarly ensure that the contour levels are consistent, as well.\n\n","type":"content","url":"/notebooks/animation#creating-the-initial-frame","position":31},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the update function","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-update-function","position":32},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the update function","lvl2":"Function animation"},"content":"Now that we have our initial frame, we need to create an update function that will update the data in the plot to create each frame of the animation. This function will be passed in as an argument to FuncAnimation, which expects a function that takes in a single argument, i, which is the frame number of the animation. The argument i is used to index into the data to get the data for the current frame to plot.\n\n# create function to update plot\ndef animate(i):\n    # Plot the new frame\n    t[i, :, :].plot.contourf(\n        ax=ax,\n        transform=ccrs.PlateCarree(),\n        vmin=vmin,\n        vmax=vmax,\n        levels=levels,\n        cmap=\"inferno\",\n        add_colorbar=False,\n    )\n\n\nNote here that that the only differences from our initial frame set up are the indexing on the data to plot and the add_colorbar = False kwarg in plt.contourf. This is because we’ve already created a colorbar in the initial frame that we want to use for all frames of the animation.\n\nWarning\n\nYou can accidentally create some funny looking animations if you forget the add_colorbar = False kwarg in the update function.\n\n","type":"content","url":"/notebooks/animation#creating-the-update-function","position":33},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the animation","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#creating-the-animation","position":34},{"hierarchy":{"lvl1":"Animation","lvl3":"Creating the animation","lvl2":"Function animation"},"content":"Now it’s time to create the animation using FuncAnimation.\n\nani = animation.FuncAnimation(fig, animate, frames=len(t), interval=150, repeat_delay=1000)\n\nThis function looks similar to ArtistAnimation, but with one main difference: instead of a list of artists to plot, FuncAnimation takes the update function we created as the second argument. Also, we’ve provided the frames kwarg, which is the number of times the update function will be called. We’ve set it to the number of time slices in the data to make sure the FuncAnimation object does not try to go outside the bounds of the data.\n\nAnd that’s it! We’ve created a function animation in matplotlib. Let’s take a look at it.\n\nani\n\n","type":"content","url":"/notebooks/animation#creating-the-animation","position":35},{"hierarchy":{"lvl1":"Animation","lvl3":"Saving the animation","lvl2":"Function animation"},"type":"lvl3","url":"/notebooks/animation#saving-the-animation-1","position":36},{"hierarchy":{"lvl1":"Animation","lvl3":"Saving the animation","lvl2":"Function animation"},"content":"Just like with ArtistAnimation, we can save the animation using the save method of the FuncAnimation object.\n\nani.save(\"temp.gif\")\n\n","type":"content","url":"/notebooks/animation#saving-the-animation-1","position":37},{"hierarchy":{"lvl1":"Animation","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/animation#summary","position":38},{"hierarchy":{"lvl1":"Animation","lvl2":"Summary"},"content":"Creating animations in matplotlib might seem intimidating, but is easier when you know the options and purpose of each method. These visualizations can be a powerful tool to display and understand time-dependent data.","type":"content","url":"/notebooks/animation#summary","position":39},{"hierarchy":{"lvl1":"Animation","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/animation#whats-next","position":40},{"hierarchy":{"lvl1":"Animation","lvl3":"What’s next?","lvl2":"Summary"},"content":"In the final section of this cookbook, let’s look at \n\ninteractive plotting with Holoviz tools.\n\n","type":"content","url":"/notebooks/animation#whats-next","position":41},{"hierarchy":{"lvl1":"Animation","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/animation#resources-and-references","position":42},{"hierarchy":{"lvl1":"Animation","lvl2":"Resources and references"},"content":"matplotlib animation documentation\n\nFuncAnimation documentation\n\nArtistAnimation documentation\n\nimshow documentation\n\nGeoColor fact sheet\n\nGOES-16 mission page\n\nGOES Image Viewer","type":"content","url":"/notebooks/animation#resources-and-references","position":43},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1}]}